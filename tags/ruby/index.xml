<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>METAREAL</title>
    <link>http://www.metareal.org/tags/ruby/index.xml</link>
    <description>Recent content on METAREAL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <copyright>copyright © 2006-Present Takanori Ishikawa.</copyright>
    <atom:link href="http://www.metareal.org/tags/ruby/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>FileUtils in Rakefile</title>
      <link>http://www.metareal.org/post/2016/09/fileutils-in-rakefile/</link>
      <pubDate>Thu, 22 Sep 2016 19:26:18 +0900</pubDate>
      
      <guid>http://www.metareal.org/post/2016/09/fileutils-in-rakefile/</guid>
      <description>&lt;p&gt;いつまでたっても Rakefile の書き方を覚える気になれないのだが、Rakefile では
&lt;a href=&#34;https://docs.ruby-lang.org/ja/latest/class/FileUtils.html&#34;&gt;FileUtils&lt;/a&gt; が
インクルードされており &lt;code&gt;cp&lt;/code&gt; や &lt;code&gt;mkdir_p&lt;/code&gt; といったメソッドが使える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mkdir_p &amp;quot;dir1/dir2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、いくつかの拡張がされており、コマンドの実行が失敗したときに例外が投げられたり、&lt;code&gt;sh&lt;/code&gt; メソッドという
&lt;code&gt;Kernel.system&lt;/code&gt; にように外部コマンドを呼び出すメソッドが追加されている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/vzvu3k6k/items/7e6e5520eeb829ec1c8b&#34;&gt;Rakeのshで外部コマンドを実行する - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ruby/rake/blob/master/lib/rake/file_utils.rb&#34;&gt;rake/file_utils.rb at master · ruby/rake&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ruby-FFI 1.0.0 からは Ruby 1.9.2 以降が必要になった</title>
      <link>http://www.metareal.org/2010/12/16/ffi-requires-ruby-version-1-9-2/</link>
      <pubDate>Thu, 16 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>http://www.metareal.org/2010/12/16/ffi-requires-ruby-version-1-9-2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/ffi/ffi&#34;&gt;Ruby-FFI 1.0.0&lt;/a&gt; からは &lt;a href=&#34;http://groups.google.com/group/ruby-ffi/browse_thread/thread/c40766b574a15962&#34;&gt;Ruby 1.9.2 以降が必要になった&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;% sudo gem1.8 install ffi
Password:
ERROR:  Error installing ffi:
        ffi requires Ruby version &amp;gt;= 1.9.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのため、Ruby 1.8 向けの gem をインストールするときはバージョン 0.6.3 を指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;% sudo gem1.8 install ffi --version &amp;quot;= 0.6.3&amp;quot;
Password:
Building native extensions.  This could take a while...
Successfully installed ffi-0.6.3
1 gem installed
Installing ri documentation for ffi-0.6.3...
Installing RDoc documentation for ffi-0.6.3...
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ruby FFI のメモリ管理についてメモ</title>
      <link>http://www.metareal.org/2010/12/11/1292077318/</link>
      <pubDate>Sat, 11 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>http://www.metareal.org/2010/12/11/1292077318/</guid>
      <description>&lt;p&gt;Ruby FFI のメモリ管理についてメモ。FFI::MemoryPointer で確保したメモリを自分で破棄する場合は、autorelease を false にする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;error   = FFI::MemoryPointer.new(:pointer)
...
C.LLVMDisposeMessage(error)
error.autorelease=false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そうしないと、FFI::MemoryPointer は GC 時に確保したメモリを破棄しようとする (&lt;a href=&#34;https://github.com/ffi/ffi/blob/1.0.1/ext/ffi_c/MemoryPointer.c#L138&#34;&gt;MemoryPointer.c#L138&lt;/a&gt;) ので、たとえば Mac OS X では以下のようなエラーが出る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruby(891,0x7fff70874ca0) malloc: *** error for object 0x102e8fb10: pointer being freed was not allocated
*** set a breakpoint in malloc_error_break to debug
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラー処理とかでは割と忘れがちかもしれない。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ruby-openid でログの出力先を変更する</title>
      <link>http://www.metareal.org/2008/04/18/ruby-openid-util-logger/</link>
      <pubDate>Fri, 18 Apr 2008 07:41:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/04/18/ruby-openid-util-logger/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://rubyforge.org/projects/ruby-openid/&#34;&gt;ruby-openid&lt;/a&gt; は Ruby の OpenID ライブラリだが、そのままだとログの出力先が標準エラー出力に向けられている。これでは何かと困ることもあるだろう（たとえば、ユニットテストの結果に ruby-openid のデバッグ出力が混じって鬱陶しい、とか）。&lt;/p&gt;

&lt;p&gt;幸い OpenID::Util モジュールに、内部で使われているロガーを変更するためのメソッドが用意されている。以下のようにすれば、Rails 標準のロガーに置き換えることが可能だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ruby-openid の Logger を Rails 標準のもので置き換える
OpenID::Util.logger = RAILS_DEFAULT_LOGGER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RAILS_DEFAULT_LOGGER&lt;/code&gt; 定数など、Rails のロガー周りについては &lt;a href=&#34;http://wiki.rubyonrails.org/rails/pages/HowtoConfigureLogging&#34;&gt;Wiki のまとめ&lt;/a&gt;が参考になる。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Array#product For Ruby 1.8</title>
      <link>http://www.metareal.org/2008/02/16/array-product-for-ruby-1-8/</link>
      <pubDate>Sun, 17 Feb 2008 07:07:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/02/16/array-product-for-ruby-1-8/</guid>
      <description>&lt;p&gt;Ruby 1.9 には配列同士の組み合わせを列挙する &lt;a href=&#34;http://doc.loveruby.net/refm/api/view/method/Array/i/product&#34;&gt;Array#product&lt;/a&gt; があるらしいのだが、Ruby 1.8 でも使いたくなったので実装してみた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Array

  # Array#product
  # -------------
  # Returns the cartesian product of the receiver and the arrays given as arguments.
  #
  # Usage:
  #   [1, 2, 3].product([4, 5])     # =&amp;gt; [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]
  #   [1, 2].product([1, 2])        # =&amp;gt; [[1, 1], [1, 2], [2, 1], [2, 2]]
  #   [1, 2].product([3, 4],[5, 6]) # =&amp;gt; [[1, 3, 5], [1, 3, 6], [1, 4, 5], [1, 4, 6],
  #                                 #     [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6]]
  #   [1, 2].product()              # =&amp;gt; [[1], [2]]
  #   [1, 2].product([])            # =&amp;gt; []
  #
  #   [1] * [2, 3]                  # =&amp;gt; [[1, 2], [1, 3]]
  #   [1, 2] * [3, 4]               # =&amp;gt; [[1, 3], [1, 4], [2, 3], [2, 4]]
  #
  def product(*others)
    arrays = [ self.map {|i| [i] } ].concat(others)
    arrays.inject do |result, item|
      (result * item).map do |t|
        t[0].dup &amp;lt;&amp;lt; t[1]
      end
    end
  end

  def multiplication_operator_with_product(other)
    unless other.kind_of? Array
      multiplication_operator_without_product(other)
    else
      self.inject([]) do |ret, i|
        ret.concat( other.map {|j| [i, j]} )
      end
    end
  end

  alias_method :multiplication_operator_without_product, :*
  alias_method :*, :multiplication_operator_with_product

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コメントにも書いてあるが、実行例は以下のとおり。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; [1, 2, 3].product([4, 5])
=&amp;gt; [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]
&amp;gt;&amp;gt; [1, 2].product([3, 4],[5, 6])
=&amp;gt; [[1, 3, 5], [1, 3, 6], [1, 4, 5], [1, 4, 6], [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6]]
&amp;gt;&amp;gt; [1, 2] * [3, 4]
=&amp;gt; [[1, 3], [1, 4], [2, 3], [2, 4]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;長らく放置気味だった &lt;a href=&#34;http://snipplr.com/view/5087/arrayproduct-for-ruby-18/&#34;&gt;Shipplr にもアップしておいた&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rparsec での繰り返しと選択</title>
      <link>http://www.metareal.org/2007/12/16/rparsec-quantifier-and-alternation/</link>
      <pubDate>Sun, 16 Dec 2007 11:10:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/12/16/rparsec-quantifier-and-alternation/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://docs.codehaus.org/display/JPARSEC/Ruby+Parsec&#34;&gt;rparsec&lt;/a&gt; では文法要素の繰り返しを指定する方法が複数用意されている。&lt;/p&gt;

&lt;h3 id=&#34;繰り返し&#34;&gt;繰り返し&lt;/h3&gt;

&lt;p&gt;まずは「&lt;a href=&#34;http://weblog.metareal.org/2007/12/13/what-is-the-difference-between-many-and-many_-of-rparsec/&#34;&gt;RParsec の many と many_ の違い&lt;/a&gt;」でも解説した &lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/classes/Parser.html#M000016&#34;&gt;&lt;code&gt;many&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/classes/Parser.html#M000015&#34;&gt;&lt;code&gt;many_&lt;/code&gt;&lt;/a&gt; があり、これで m 回以上の繰り返しを指定できる（正規表現でいう &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;{n,}&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/classes/Parser.html#M000014&#34;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/classes/Parser.html#M000013&#34;&gt;&lt;code&gt;repeat_&lt;/code&gt;&lt;/a&gt; は m 回以上、最大 n 回の繰り返しを指定できる（正規表現でいえば &lt;code&gt;{m,n}&lt;/code&gt;）。また、&lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/classes/Parser.html#M000018&#34;&gt;&lt;code&gt;some&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/classes/Parser.html#M000017&#34;&gt;&lt;code&gt;some_&lt;/code&gt;&lt;/a&gt; では最大 n 回の繰り返しを指定できる（正規表現でいえば &lt;code&gt;{0,n}&lt;/code&gt;。実際のところ、some は &lt;code&gt;min&lt;/code&gt; 引数に &lt;code&gt;0&lt;/code&gt; を指定して、repeat を呼び出しているにすぎない）。&lt;/p&gt;

&lt;p&gt;なお、メソッド名の最後にあるアンダースコアの有無については、「&lt;a href=&#34;http://weblog.metareal.org/2007/12/13/what-is-the-difference-between-many-and-many_-of-rparsec/&#34;&gt;RParsec の many と many_ の違い&lt;/a&gt;」で解説したとおりで、アンダースコアのつかないメソッドはすべての結果を配列で返し、アンダースコアのつくメソッドは最後の結果のみを返す。&lt;/p&gt;

&lt;h3 id=&#34;選択&#34;&gt;選択&lt;/h3&gt;

&lt;p&gt;正規表現でいうところの選択も用意されている。このためのメソッドは &lt;code&gt;|&lt;/code&gt; なので、見た目は正規表現と似通っている。&lt;/p&gt;

&lt;p&gt;たとえば、以下のコードは、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;number | word
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数値、または一般的な識別子を解釈するためのパーサになる。&lt;/p&gt;

&lt;p&gt;また、文法要素のグループ化は簡単で、通常の Ruby プログラムと同じく括弧で囲めばよい。たとえば、空白区切りの数値、または識別子を解釈するためのパーサは以下のように書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;parser = ((number | word) &amp;lt;&amp;lt; whitespace.many_).many
parser.parse(&amp;quot;123 abc 56.7&amp;quot;) =&amp;gt; [&amp;quot;123&amp;quot;, &amp;quot;abc&amp;quot;, &amp;quot;56.7&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/classes/Parser.html#M000022&#34;&gt;&lt;code&gt;Parser#delimited&lt;/code&gt;&lt;/a&gt; を使って、もっと直感的に書くこともできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;parser = (number | word).delimited(whitespaces)
parser.parse(&amp;quot;123 abc 56.7&amp;quot;) =&amp;gt; [&amp;quot;123&amp;quot;, &amp;quot;abc&amp;quot;, &amp;quot;56.7&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>rparsec の四則演算デモを浮動小数点に対応させる</title>
      <link>http://www.metareal.org/2007/12/14/floating-point-arithmetic-of-rparsec-calculator-demo/</link>
      <pubDate>Fri, 14 Dec 2007 10:05:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/12/14/floating-point-arithmetic-of-rparsec-calculator-demo/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://docs.codehaus.org/display/JPARSEC/Ruby+Parsec&#34;&gt;rparsec&lt;/a&gt; の&lt;a href=&#34;http://weblog.metareal.org/2007/12/11/studying-rparsec-introduction/#rparsec-calculator-demo&#34;&gt;四則演算デモ&lt;/a&gt;を試しているうちに、整数による演算しかできないことに気づくことと思う。&lt;/p&gt;

&lt;p&gt;四則演算デモが &lt;code&gt;calculator.rb&lt;/code&gt; にあるとして、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &#39;calculator.rb&#39;
parser = Calculator.new.parser
parser.parse &#39;1+2*(3-1)&#39;
=&amp;gt; 5
parser.parse &#39;4 * 2.5&#39;
=&amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小数を計算させてみると、エラーにはならないものの、計算結果がおかしなことになっている。&lt;/p&gt;

&lt;p&gt;実は、この四則演算デモは数値として整数しか解釈しない。そのため、&lt;code&gt;4 * 2.5&lt;/code&gt; を計算させたときは、&lt;code&gt;2.5&lt;/code&gt; の &lt;code&gt;&amp;quot;.&amp;quot;&lt;/code&gt; で解釈をやめてしまい、そこまでの &lt;code&gt;4 * 2&lt;/code&gt; を計算して返した、という具合だ。&lt;/p&gt;

&lt;p&gt;ソースコードで数値をパースしている箇所は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;term = integer.map(&amp;amp;To_i) | char(&#39;(&#39;) &amp;gt;&amp;gt; lazy{expr} &amp;lt;&amp;lt; char(&#39;)&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうみても、この行の左半分なので、ここを &lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/&#34;&gt;API リファレンス&lt;/a&gt;を参考に、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;term = number.map(&amp;amp;To_f) | char(&#39;(&#39;) &amp;gt;&amp;gt; lazy{expr} &amp;lt;&amp;lt; char(&#39;)&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こう書き換えれば動く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;parser.parse &#39;4 * 2.5&#39;
=&amp;gt; 10.0
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>RParsec の many と many_ の違い</title>
      <link>http://www.metareal.org/2007/12/13/what-is-the-difference-between-many-and-many_-of-rparsec/</link>
      <pubDate>Thu, 13 Dec 2007 09:09:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/12/13/what-is-the-difference-between-many-and-many_-of-rparsec/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://weblog.metareal.org/2007/12/11/studying-rparsec-introduction/#rparsec-calculator-demo&#34;&gt;前回の四則演算デモ&lt;/a&gt;で真っ先に目を引いたのは &lt;code&gt;many_&lt;/code&gt; という奇妙な名前のメソッドだった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;delim = whitespace.many_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他にもっと注目すべきところがあるだろうと言われそうだが、&lt;strong&gt;非公開の関数か一時変数のようなメソッド&lt;/strong&gt;が公開 API の一部というのに驚いた。&lt;/p&gt;

&lt;p&gt;また、&lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/classes/Parser.html#M000015&#34;&gt;many_&lt;/a&gt; は &lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/classes/Parser.html&#34;&gt;Parser&lt;/a&gt; クラスのメソッドだが、このクラスには他にも &lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/classes/Parser.html#M000016&#34;&gt;many&lt;/a&gt; というメソッドが用意されている。&lt;/p&gt;

&lt;p&gt;両者の違いは何だろう？&lt;/p&gt;

&lt;h3 id=&#34;many-と-many-の違い&#34;&gt;many と many_ の違い&lt;/h3&gt;

&lt;p&gt;上記リンク先の API リファレンスによれば、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;many は複数回マッチしたそれぞれの結果を配列で返し、&lt;/li&gt;
&lt;li&gt;many_ は最後にマッチした結果のみを返す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という違いだけのようだ。irb で実際に動作を確認してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% irb
irb(main):001:0&amp;gt; require &#39;rubygems&#39;
irb(main):002:0&amp;gt; require &#39;rparsec&#39;
irb(main):003:0&amp;gt; include Parsers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずは必要な require や include を済ませておく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;irb(main):004:0&amp;gt; whitespace.many.parse(&amp;quot;\t\r\n&amp;quot;)
=&amp;gt; [9, 13, 10]
irb(main):005:0&amp;gt; whitespace.many_.parse(&amp;quot;\t\r\n&amp;quot;)
=&amp;gt; 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;many では引数で渡した文字列（タブと改行）の各文字が配列で返されるのにたいして、many_ では最後の改行文字のみが返されているのが確認できた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;irb(main):007:0&amp;gt; whitespace.many.parse(&amp;quot;&amp;quot;)
=&amp;gt; []
irb(main):006:0&amp;gt; whitespace.many_.parse(&amp;quot;&amp;quot;)
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、一度もマッチしなかった場合は many では空の配列、many_ では nil が返されるようだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby によるパーサ・コンビネータ rparsec</title>
      <link>http://www.metareal.org/2007/12/11/studying-rparsec-introduction/</link>
      <pubDate>Tue, 11 Dec 2007 10:52:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/12/11/studying-rparsec-introduction/</guid>
      <description>

&lt;p&gt;Java による &lt;a href=&#34;http://www.lab2.kuis.kyoto-u.ac.jp/~hanatani/tmp/Parsec.html&#34;&gt;parsec&lt;/a&gt; の実装 &lt;a href=&#34;http://docs.codehaus.org/display/JPARSEC/Home&#34;&gt;JParsec&lt;/a&gt; を Ruby に移植した &lt;a href=&#34;http://docs.codehaus.org/display/JPARSEC/Ruby+Parsec&#34;&gt;rparsec&lt;/a&gt; を勉強中。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.codehaus.org/display/JPARSEC/rparsec+overview&#34;&gt;rparsec overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jparsec.codehaus.org/rparsec/api/&#34;&gt;rparsec RDoc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;パーサ-コンビネータ&#34;&gt;パーサ・コンビネータ&lt;/h3&gt;

&lt;p&gt;Parsec、パーサ・コンビネータについては「&lt;a href=&#34;http://d.hatena.ne.jp/tanakh/20040730&#34;&gt;最強のパーザー、Parser Combinator - 純粋関数型雑記帳&lt;/a&gt;」が参考になる。&lt;/p&gt;

&lt;p&gt;Yacc や Bison などのコンパイラ・コンパイラと比較したときのパーサ・コンビネータの強味としては、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;パーサを実装言語と同じ言語で書ける&lt;/li&gt;
&lt;li&gt;プログラムがそのまま文法定義のように読める&lt;/li&gt;
&lt;li&gt;パーサは普通の関数やオブジェクトなので、パーサをラップした別のパーサを生成する関数を定義したりするのも簡単にできる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などがあるようだ。&lt;/p&gt;

&lt;h3 id=&#34;rparsec-のインストール&#34;&gt;rparsec のインストール&lt;/h3&gt;

&lt;p&gt;普通に &lt;a href=&#34;http://rubyforge.org/projects/rparsec/&#34;&gt;RubyForge&lt;/a&gt; で gem がホスティングされているので、&lt;code&gt;gem&lt;/code&gt; コマンド一発でインストールできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% sudo gem install rparsec
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;四則演算デモ&#34;&gt;四則演算デモ&lt;/h3&gt;

&lt;p&gt;まずは公式ページにもデモとして紹介されている四則演算から。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/local/bin/ruby
require &#39;rubygems&#39;
require &#39;rparsec&#39;

class Calculator
  include Parsers
  include Functors
  def parser
    ops = OperatorTable.new.
      infixl(char(?+) &amp;gt;&amp;gt; Plus, 20).
      infixl(char(?-) &amp;gt;&amp;gt; Minus, 20).
      infixl(char(?*) &amp;gt;&amp;gt; Mul, 40).
      infixl(char(?/) &amp;gt;&amp;gt; Div, 40).
      prefix(char(?-) &amp;gt;&amp;gt; Neg, 60)
    expr = nil
    term = integer.map(&amp;amp;To_i) | char(&#39;(&#39;) &amp;gt;&amp;gt; lazy{expr} &amp;lt;&amp;lt; char (&#39;)&#39;)
    delim = whitespace.many_
    expr = delim &amp;gt;&amp;gt; Expressions.build(term, ops, delim)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを calc.rb として保存し、irb から簡単な数式を処理させてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% irb
irb(main):001:0&amp;gt; require &#39;calc&#39;
=&amp;gt; true
irb(main):002:0&amp;gt; Calculator.new.parser.parse &#39;1+2*(3-1)&#39;
=&amp;gt; 5
# =&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ruby で16進数表記の整数を UTF-8 文字列として出力する</title>
      <link>http://www.metareal.org/2007/12/10/packing-integer-into-utf8-sequence-bytes/</link>
      <pubDate>Mon, 10 Dec 2007 10:16:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/12/10/packing-integer-into-utf8-sequence-bytes/</guid>
      <description>&lt;p&gt;前回の記事「&lt;a href=&#34;http://weblog.metareal.org/2007/12/10/postgresql-rejects-invalidly-encoded-multibyte-character/&#34;&gt;PostgreSQL 7.4.13 以降、異なるエンコーディングでの変換エラー&lt;/a&gt;」でも書いたように、PostgreSQL で以下のようなエラーが出るようになった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR:  22P05: character 0xe28094 of encoding &amp;quot;UNICODE&amp;quot; has no equivalent in &amp;quot;EUC_JP&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、&lt;code&gt;character 0xe28094&lt;/code&gt; とは、どの文字なのか。&lt;/p&gt;

&lt;p&gt;PostgreSQL では &lt;code&gt;UNICODE&lt;/code&gt; という名前のエンコーディングは UTF-8 のことなので、Ruby の &lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=Array#pack&#34;&gt;Array#pack&lt;/a&gt; を使えば、0xe28094 という16進数表記の整数を UTF-8 文字列に変換できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruby -e &#39;puts [ARGV[0]].pack(&amp;quot;H*&amp;quot;)&#39; &amp;quot;e28094&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ruby の CSS パーサはどこですか？</title>
      <link>http://www.metareal.org/2007/11/23/looking-for-ruby-css-parser/</link>
      <pubDate>Sat, 24 Nov 2007 02:58:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/11/23/looking-for-ruby-css-parser/</guid>
      <description>

&lt;p&gt;「Ruby で書かれた CSS パーサを探しています」メモ。&lt;/p&gt;

&lt;h3 id=&#34;ruby-css-parser-http-rubyforge-org-projects-cssparser&#34;&gt;&lt;a href=&#34;http://rubyforge.org/projects/cssparser/&#34;&gt;Ruby CSS Parser&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;最近 RubyForge に登録されたばかりのプロジェクト&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gem install css_parser&lt;/code&gt; で試してみる&lt;/li&gt;
&lt;li&gt;いきなり、&lt;a href=&#34;http://code.dunae.ca/css_parser/&#34;&gt;ドキュメント&lt;/a&gt;と実際の挙動が違う。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CssParser::Parser#load_file!&lt;/code&gt; というメソッドはなくて &lt;code&gt;CssParser::Parser#load_uri!&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;とりあえずローカルファイルを読み込む方法がないようだ&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3.org/StyleSheets/home.css&#34;&gt;W3C のスタイルシート&lt;/a&gt;で試してみたがエラー&lt;/li&gt;
&lt;li&gt;まだ実用ではない、ということだろう&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;csspool-http-rubyforge-org-projects-csspool&#34;&gt;&lt;a href=&#34;http://rubyforge.org/projects/csspool/&#34;&gt;csspool&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;W3C で公開されている CSS パーサのための共通 API &lt;a href=&#34;http://www.w3.org/TR/SAC/&#34;&gt;SAC&lt;/a&gt;（&lt;a href=&#34;http://www2.airnet.ne.jp/sardine/docs/NOTE-SAC-20000728.ja.html&#34;&gt;和訳&lt;/a&gt;）の Ruby による実装。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;なので、委員会っぽい API&lt;/li&gt;
&lt;li&gt;あらかじめ &lt;a href=&#34;http://i.loveruby.net/ja/projects/racc/&#34;&gt;racc&lt;/a&gt;, &lt;a href=&#34;http://onestepback.org/software/flexmock/&#34;&gt;flexmock&lt;/a&gt; のインストールが必要&lt;/li&gt;
&lt;li&gt;何を間違ったのか、gem でインストールしたあとに、手動で rake しないと動かなかった&lt;/li&gt;
&lt;li&gt;パースできるファイルとできないファイルがある&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@charset&lt;/code&gt; 規則があるものは駄目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;うーん、単に特定のプロパティをもつセレクタを抜き出したいだけなんだが、どちらのライブラリでも出来ないという罠。自分で書き捨てのスクリプトでも書いて、急場を凌ぐしかないのか。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby で平仮名にマッチする正規表現</title>
      <link>http://www.metareal.org/2007/11/18/ruby-needs-unicode-regular-expressions/</link>
      <pubDate>Mon, 19 Nov 2007 02:31:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/11/18/ruby-needs-unicode-regular-expressions/</guid>
      <description>

&lt;p&gt;Ruby 1.8 系で平仮名にマッチする正規表現を書きたい。&lt;/p&gt;

&lt;p&gt;正規表現で &lt;a href=&#34;http://www.unicode.org/Public/UNIDATA/Blocks.txt&#34;&gt;Unicode ブロック&lt;/a&gt;が使えれば楽なのだが、残念ながら Ruby 1.8 ではサポートされていない。&lt;/p&gt;

&lt;h3 id=&#34;鬼車&#34;&gt;鬼車&lt;/h3&gt;

&lt;p&gt;ちなみに 1.9 で搭載される予定の&lt;a href=&#34;http://www.geocities.jp/kosako3/oniguruma/index_ja.html&#34;&gt;鬼車&lt;/a&gt;では、以下のような形式で Unicode ブロックやカテゴリを指定できるようだ（参考：&lt;a href=&#34;http://www.geocities.jp/kosako3/oniguruma/doc/RE.ja.txt&#34;&gt;鬼車 正規表現 Version 5.6.0&lt;/a&gt;）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\p{property-name}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\p{^property-name}&lt;/code&gt;（否定）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\P{property-name}&lt;/code&gt;（否定）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もっとも、実際に試したわけではないので、現状の Ruby 1.9 で上記のような使い方ができるのかは分からない。&lt;/p&gt;

&lt;h3 id=&#34;ruby-1-8&#34;&gt;Ruby 1.8&lt;/h3&gt;

&lt;p&gt;結局、Ruby 1.8 では平仮名に相当するコードポイントの範囲を直接、正規表現で指定してやるのが簡単そうだ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.unicode.org/Public/UNIDATA/Blocks.txt&#34;&gt;Unicode Character Database の Block.txt&lt;/a&gt; によると平仮名（&lt;code&gt;Hiragana&lt;/code&gt;）の範囲は &lt;code&gt;0x3040&lt;/code&gt; から &lt;code&gt;0x309f&lt;/code&gt; なので、&lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=FAQ%3A%3A%C6%FC%CB%DC%B8%EC%A4%CE%BC%E8%A4%EA%B0%B7%A4%A4#a10.2e7.20SJIS.a4.ce.b5.a1.bc.ef.b0.cd.c2.b8.a5.b3.a1.bc.a5.c984BF.20.a4.ab.a4.e9.20889F.a4.de.a4.c7.a4.f2.b6.f5.c7.f2.a4.cb.c3.d6.a4.ad.b4.b9.a4.a8.a4.bf.a4.a4.a4.ce.a4.c7.a4.b9.a4.ac&#34;&gt;Ruby リファレンスマニュアルの FAQ「10.7 SJISの機種依存コード84BF から 889Fまでを空白に置き換えたいのですが」&lt;/a&gt;を参考に正規表現を書いてみる（ただし、UTF-8 限定）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/#{&amp;quot;[#{[0x3040].pack(&#39;U&#39;)}-#{[0x309f].pack(&#39;U&#39;)}]&amp;quot;}/u
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コードポイントから UTF-8 リテラル文字列への変換に &lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=Array#pack&#34;&gt;&lt;code&gt;Array#pack&lt;/code&gt;&lt;/a&gt; を利用しているため読みづらくなっている。もっといい方法があるのかもしれない。&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.unicode.org/reports/tr18/&#34;&gt;Unicode Regular Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.geocities.jp/kosako3/oniguruma/index_ja.html&#34;&gt;鬼車&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ruby で外部プログラムの標準エラー出力を得る方法</title>
      <link>http://www.metareal.org/2007/10/09/capture-stderr-of-external-program-into-ruby-string/</link>
      <pubDate>Wed, 10 Oct 2007 06:37:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/10/09/capture-stderr-of-external-program-into-ruby-string/</guid>
      <description>

&lt;p&gt;Ruby で外部プログラムを実行するには&lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=%C1%C8%A4%DF%B9%FE%A4%DF%B4%D8%BF%F4#a.60.20str&#34;&gt;バッククォート文字列&lt;/a&gt;がもっとも簡単だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s = `command`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすると &lt;code&gt;command&lt;/code&gt; コマンドを実行し、標準出力の結果を返り値で受け取ることができる。&lt;/p&gt;

&lt;p&gt;だが、標準エラーへの出力を得るには別の手段を用いなくてはいけない。&lt;/p&gt;

&lt;h3 id=&#34;open3&#34;&gt;open3&lt;/h3&gt;

&lt;p&gt;もちろん、あくまでバッククォート文字列にこだわって、標準エラーを標準出力にリダイレクトする、なんてのもあるわけだが、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s = `command 2&amp;gt;&amp;amp;1`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだと返り値には標準出力と標準エラーがまじってしまうので、添付ライブラリの &lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=open3&#34;&gt;&lt;code&gt;open3&lt;/code&gt;&lt;/a&gt; を使うのがいいだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &#39;open3&#39;

Open3.popen3(&amp;quot;command&amp;quot;) do |stdin, stdout, stderr|
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=open3#Open3.2epopen3&#34;&gt;&lt;code&gt;Open3.popen3&lt;/code&gt;&lt;/a&gt; で外部プログラムを実行し、そのプロセスの標準入力・標準出力・ 標準エラー出力を &lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=IO&#34;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; オブジェクトとして取得できる。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby の String#to_i と組み込み関数の Integer() は違う</title>
      <link>http://www.metareal.org/2007/10/06/ruby-to-i-and-integer-function/</link>
      <pubDate>Sat, 06 Oct 2007 10:37:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/10/06/ruby-to-i-and-integer-function/</guid>
      <description>

&lt;p&gt;文字列から数値への変換に &lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=String#to_i&#34;&gt;&lt;code&gt;String.to_i&lt;/code&gt;&lt;/a&gt; を使っていると、思わぬ問題に出くわすことがある。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=String#to_i&#34;&gt;Ruby リファレンスマニュアル&lt;/a&gt;には、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;整数とみなせない文字があればそこまでを変換対象とします。変換対象が 空文字列であれば 0 を返します。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;このように説明されているが、これをそのまま解釈すると、以下のような挙動が予想できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;irb(main):001:0&amp;gt; &amp;quot;10&amp;quot;.to_i       =&amp;gt; 10
irb(main):002:0&amp;gt; &amp;quot;10fixnum&amp;quot;.to_i =&amp;gt; 10
irb(main):003:0&amp;gt; &amp;quot;&amp;quot;.to_i         =&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、次のような挙動は意外だった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;irb(main):001:0&amp;gt; &amp;quot;  10&amp;quot;.to_i   =&amp;gt; 10
irb(main):002:0&amp;gt; &amp;quot;fixnum&amp;quot;.to_i =&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最初の例は「文字列中の先頭の空白文字は無視される」と推測できるが、次の例はどうだろうか。明らかに数値ではない文字列の場合はエラーになりそうだが、この場合、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先頭の文字 &lt;code&gt;f&lt;/code&gt; が整数とみなせない&lt;/li&gt;
&lt;li&gt;よって空文字列が変換対象&lt;/li&gt;
&lt;li&gt;変換対象が 空文字列であれば 0 を返す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という挙動らしい。&lt;/p&gt;

&lt;h3 id=&#34;変換できない場合はエラーにする&#34;&gt;変換できない場合はエラーにする&lt;/h3&gt;

&lt;p&gt;変換できないときに &lt;code&gt;0&lt;/code&gt; を返すのはコードをシンプルにできるが、バグの原因にもなりやすい。&lt;/p&gt;

&lt;p&gt;変換できない場合はエラーにしたいところだが、&lt;a href=&#34;http://weblog.metareal.org/2007/06/21/error-checking-in-ruby-time-parsing/&#34;&gt;Ruby の Time.parse で文字列を Time に変換するときのエラーチェック&lt;/a&gt;と同様、&lt;code&gt;String.to_i&lt;/code&gt; にはエラーを検出する仕組みがない。&lt;/p&gt;

&lt;p&gt;どうするか、というと組み込み関数の &lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=%C1%C8%A4%DF%B9%FE%A4%DF%B4%D8%BF%F4#Integer&#34;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;irb(main):001:0&amp;gt; Integer(&amp;quot;10fixnum&amp;quot;)
ArgumentError: invalid value for Integer: &amp;quot;10fixnum&amp;quot;
        from (irb):7:in `Integer&#39;
        from (irb):7
        from :0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=%C1%C8%A4%DF%B9%FE%A4%DF%B4%D8%BF%F4#Integer&#34;&gt;リファレンスマニュアル&lt;/a&gt;にもあるように、変換できない場合は、例外 ArgumentError が発生する。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>今日の Ruby 落とし穴</title>
      <link>http://www.metareal.org/2007/09/11/ruby-pitfall-today/</link>
      <pubDate>Wed, 12 Sep 2007 06:31:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/09/11/ruby-pitfall-today/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.ruby-lang.org/ja/man/?cmd=view;name=Ruby%A4%CE%CD%EE%A4%C8%A4%B7%B7%EA&#34;&gt;Ruby の落とし穴&lt;/a&gt;には載っていないようなので。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def
def foo
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記スクリプトは &lt;strong&gt;SyntaxError にならない&lt;/strong&gt;（&lt;code&gt;def&lt;/code&gt; がふたつあるのに注意）。&lt;/p&gt;

&lt;p&gt;しかし、実際にメソッド &lt;code&gt;foo&lt;/code&gt; を呼び出そうとすると、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def
def foo
  # ...
end
foo
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;% ruby test.rb
test.rb:5: undefined local variable or method `foo&#39; for main:Object (NameError)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;未定義だと怒られる。&lt;/p&gt;

&lt;p&gt;あと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p [1, 2, 3].map do |v|
  v + 1
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードは意図通りに動作しないどころか、&lt;strong&gt;ブロックが実行されない&lt;/strong&gt;、というのには驚いた。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>