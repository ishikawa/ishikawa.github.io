<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>METAREAL</title>
    <link>http://www.metareal.org/tags/python/index.xml</link>
    <description>Recent content on METAREAL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <copyright>copyright © 2006-Present Takanori Ishikawa.</copyright>
    <atom:link href="http://www.metareal.org/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python のクロージャとレキシカル変数を使ったシングルトンっぽいもの</title>
      <link>http://www.metareal.org/2010/01/31/python-shared-instance-closure/</link>
      <pubDate>Sun, 31 Jan 2010 18:26:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2010/01/31/python-shared-instance-closure/</guid>
      <description>&lt;p&gt;実際にはシングルトンではなくて、共有インスタンスを返すメソッドを実装する、ってだけなんだけど。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class A(object):

    @staticmethod
    def shared():
        instance = A()
        A.shared = staticmethod(lambda: instance)
        return instance
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;共有インスタンスとなるオブジェクトを生成し、レキシカル変数にバインドする&lt;/li&gt;
&lt;li&gt;このオブジェクトを返す無名関数で、元の関数 shared を置き換える&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;何が嬉しいかというと、共有インスタンスを参照するための変数（今回の場合は &lt;code&gt;instance&lt;/code&gt;）を関数外から不可視にできること。変数のスコープが必要以上に広いと不安になります。実行時に遅延インスタンス化されるのが嫌なら、クラス定義の直後に一度呼び出すなりすればいいと思う。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gist.github.com/290628&#34;&gt;gist:290628&lt;/a&gt; に doctest とか追加したものを置いてあります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google AppEngine で Django 1.1 を使う</title>
      <link>http://www.metareal.org/2009/12/02/running-django-1-1-on-google-appengine/</link>
      <pubDate>Thu, 03 Dec 2009 12:42:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2009/12/02/running-django-1-1-on-google-appengine/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://code.google.com/appengine/&#34;&gt;Google AppEngine&lt;/a&gt; の SDK および実行環境には、Web アプリケーション・フレームワークの &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; がプリインストールされている。&lt;/p&gt;

&lt;p&gt;しかし、デフォルトで有効になっているのは 0.96 という相当古いバージョンだ（もっとも、Google AppEngine リリース時点では、これが最新のバージョンであった）。すでにサポートも終了しており、バグや脆弱性の修正もされないため、できれば最新の 1.0/1.1系列を使いたい、という人が大半だろう。&lt;/p&gt;

&lt;p&gt;しかし、これまで、バージョン 1.0 以降の Django を Google AppEngine で使うのは骨の折れる作業だった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使いたいバージョンの Django を丸ごとアップロードしなくてはいけなかった&lt;/li&gt;
&lt;li&gt;Django はファイル数が多いため、アップロード可能なファイル数制限を超えやすい&lt;/li&gt;
&lt;li&gt;デフォルトで有効になる古いバージョンの Django を無効化するために、&lt;a href=&#34;http://code.google.com/intl/en/appengine/articles/django.html&#34;&gt;呪文めいたコードが必要&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;だが、いまや状況は変わった。SDK &lt;a href=&#34;http://code.google.com/p/googleappengine/wiki/SdkReleaseNotes#Version_1.2.3_-_June_18,_2009&#34;&gt;1.2.3 からは Django 1.0&lt;/a&gt; が、SDK &lt;a href=&#34;http://code.google.com/p/googleappengine/wiki/SdkReleaseNotes#Version_1.2.5_-_September_3,_2009&#34;&gt;1.2.5 からは Django 1.1&lt;/a&gt; がサポートされ、Google AppEngine でも、簡単に Django 1.x を動かせるようになった。&lt;/p&gt;

&lt;h3 id=&#34;google-appengine-dist-use-library&#34;&gt;google.appengine.dist.use_library&lt;/h3&gt;

&lt;p&gt;SDK 1.2.&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;.2.5 からは &lt;a href=&#34;http://code.google.com/p/googleappengine/source/browse/#svn/trunk/python/google/appengine/dist&#34;&gt;google.appengine.dist&lt;/a&gt; モジュールの &lt;code&gt;use_library&lt;/code&gt; 関数を使うことで Django 1.0/1.1 を選択できるようになった。&lt;/p&gt;

&lt;p&gt;使い方は簡単で、&lt;code&gt;main.py&lt;/code&gt; に以下のような記述を追加するだけだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import os
os.environ[&#39;DJANGO_SETTINGS_MODULE&#39;] = &#39;settings&#39;

from google.appengine.dist import use_library
use_library(&#39;django&#39;, &#39;1.1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これまで開発者が各自行っていた &lt;code&gt;sys.path&lt;/code&gt; の調整は &lt;code&gt;use_library&lt;/code&gt; 関数がやってくれる。&lt;/p&gt;

&lt;p&gt;更に嬉しいことに、Django のコードをアップロードする必要もなくなった。Google AppEngine のサーバには Django 1.0/1.1 がインストールされている。ただし、SDK には Django 0.96 しか添付されていないので、1.0/1.1 を使う場合は、あらかじめローカルのマシンに Django 1.0/1.1 をインストールしておこう。&lt;/p&gt;

&lt;h3 id=&#34;django-のバージョンと-dos-攻撃可能な脆弱性について&#34;&gt;Django のバージョンと DoS 攻撃可能な脆弱性について&lt;/h3&gt;

&lt;p&gt;なお、実際に有効になる Django の詳細なバージョンは、本記事執筆時点の 2009 年 11 月で以下のようになっている（&lt;code&gt;django.VERSION&lt;/code&gt; で調べた）。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;use_library&lt;/th&gt;
&lt;th&gt;Django version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;(None)&lt;/td&gt;
&lt;td&gt;0.96.4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;use_library(1.0)&lt;/td&gt;
&lt;td&gt;1.0.2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;use_library(1.1)&lt;/td&gt;
&lt;td&gt;1.1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;del&gt;残念ながら、1.0/1.1 は &lt;a href=&#34;http://www.djangoproject.com/weblog/2009/oct/09/security/&#34;&gt;DoS 攻撃可能な脆弱性が修正されたバージョン&lt;/a&gt; ではないようだ（修正バージョンは 1.0.&lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;.1.1）。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;この脆弱性は &lt;code&gt;EmailField&lt;/code&gt; か &lt;code&gt;URLField&lt;/code&gt; に関連したものなので、それらを使っているプログラムでは Google AppEngine にインストールされた Django のアップデートを待つか、これまでどおりの方法で、修正済みのバージョンをアップロードした方が安全だろう。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Google AppEngine プロジェクトに&lt;a href=&#34;http://code.google.com/p/googleappengine/issues/detail?id=2447&#34;&gt;報告&lt;/a&gt;したところ、GAE で有効になるバージョンは修正済みのものである、とのこと。失礼しました。&lt;/p&gt;

&lt;h3 id=&#34;main-py-のサンプル&#34;&gt;main.py のサンプル&lt;/h3&gt;

&lt;p&gt;実際に &lt;code&gt;use_library&lt;/code&gt; を使ったサンプルを &lt;a href=&#34;http://gist.github.com/245523&#34;&gt;gist:245523&lt;/a&gt; で公開している。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sphinx 0.6.2 にアップグレードしたときのメモ</title>
      <link>http://www.metareal.org/2009/07/27/upgrading-sphinx-0-6-2/</link>
      <pubDate>Mon, 27 Jul 2009 10:45:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2009/07/27/upgrading-sphinx-0-6-2/</guid>
      <description>

&lt;p&gt;約一年ぶりに &lt;a href=&#34;http://sphinx.pocoo.org/&#34;&gt;Sphinx&lt;/a&gt; を最新版に&amp;hellip;しようとしたら色々苦労したので、変更点や手順をメモとして残しておく。&lt;/p&gt;

&lt;h3 id=&#34;sphinx-0-6-2-jinja2-2-1-1&#34;&gt;Sphinx 0.6.2 &amp;amp; Jinja2 2.1.1&lt;/h3&gt;

&lt;p&gt;easy_install でインストールしようとしたが、&lt;a href=&#34;http://jinja.pocoo.org/2/&#34;&gt;Jinja2&lt;/a&gt; のセットアップ・スクリプトがうまく動いていないらしく、Jinja2 に依存している Sphinx もインストールできない。原因を調べる気力はないので、ソースコードからビルドしてインストールすることにした。&lt;/p&gt;

&lt;p&gt;まずは &lt;a href=&#34;http://pypi.python.org/pypi/Jinja2&#34;&gt;Jinja2 2.1.1&lt;/a&gt; をビルドしてインストール。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% curl -LO http://pypi.python.org/packages/source/J/Jinja2/Jinja2-2.1.1.tar.gz
% tar xvzf Jinja2-2.1.1.tar.gz
% cd Jinja2-2.1.1
% sudo python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つづいて &lt;a href=&#34;http://pypi.python.org/pypi/Sphinx/0.6.2&#34;&gt;Sphinx 0.6.2&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% curl -LO http://pypi.python.org/packages/source/S/Sphinx/Sphinx-0.6.2.tar.gz
% tar xvzf Sphinx-0.6.2.tar.gz
% cd Sphinx-0.6.2
% sudo python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sphinx-builder&#34;&gt;sphinx.builder&lt;/h3&gt;

&lt;p&gt;Sphinx 0.6.2 では &lt;code&gt;sphinx.builder&lt;/code&gt; が非推奨扱いになっていた (&lt;a href=&#34;http://bitbucket.org/birkenfeld/sphinx/changeset/254e0ff435e8/&#34;&gt;changeset:254e0ff435e8&lt;/a&gt;)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Running Sphinx v0.6.2
docs/ja/source/../../sphinxext/__init__.py:1:
DeprecationWarning: The sphinx.builder module is deprecated; please import builders from the respective sphinx.builders submodules.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のバージョンでは&lt;a href=&#34;http://bitbucket.org/birkenfeld/sphinx/changeset/7da5ae249f61/&#34;&gt;削除されている&lt;/a&gt;ようだし、モジュール名を適切に直す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-from sphinx.builder import StandaloneHTMLBuilder
+from sphinx.builders.html import StandaloneHTMLBuilder
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unicodedecodeerror&#34;&gt;UnicodeDecodeError&lt;/h3&gt;

&lt;p&gt;今度は、日本語を含むドキュメントを変換しようとすると UnicodeDecodeError が発生する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exception occurred:
  File &amp;quot;/Library/Python/2.5/site-packages/Sphinx-0.6.2-py2.5.egg/sphinx/themes/basic/layout.html&amp;quot;, line 19, in block &amp;quot;rootrellink&amp;quot;
    &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{{ pathto(master_doc) }}&amp;quot;&amp;gt;{{ shorttitle|e }}&amp;lt;/a&amp;gt;{{ reldelim1 }}&amp;lt;/li&amp;gt;
UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xe3 in position 8: ordinal not in range(128)
The full traceback has been saved in /var/folders/Xg/XgsbIugsGWiYSnTBrMoebU+++TI/-Tmp-/sphinx-err-cfE9NN.log, if you want to report the issue to the author.
Please also report this if it was a user error, so that a better error message can be provided next time.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら、&lt;code&gt;conf.py&lt;/code&gt; に &lt;strong&gt;str&lt;/strong&gt; で日本語を書いていたのが原因らしい。&lt;strong&gt;unicode&lt;/strong&gt; リテラルで書き直したらうまくいった。&lt;a href=&#34;http://jinja.pocoo.org/2/documentation/api#unicode&#34;&gt;Jinja2 の Unicode 対応&lt;/a&gt;が原因だろうか。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python の dis モジュールでさまざまな import 文を disassemble する (2)</title>
      <link>http://www.metareal.org/2008/09/25/disassembling-python-import-statements-take2/</link>
      <pubDate>Thu, 25 Sep 2008 17:39:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/09/25/disassembling-python-import-statements-take2/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.metareal.org/2008/09/25/disassembling-python-import-statements/&#34;&gt;前回の記事&lt;/a&gt;への追記が長くなりそうなので、新しい記事にまとめました。&lt;/p&gt;

&lt;h3 id=&#34;import-module-と-import-module-as-name&#34;&gt;import &lt;module&gt; と import &lt;module&gt; as &lt;name&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;import &amp;lt;module&amp;gt;&lt;/code&gt; と &lt;code&gt;import &amp;lt;module&amp;gt; as &amp;lt;name&amp;gt;&lt;/code&gt; では、どのようなバイトコードにコンパイルされるか、つまり、実行時の振る舞いが&lt;strong&gt;微妙に異なる&lt;/strong&gt;ことに注意しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dis.disassemble(compile(&#39;import os.path&#39;, &#39;&#39;, &#39;exec&#39;))
  1           0 LOAD_CONST               0 (-1)
              3 LOAD_CONST               1 (None)
              6 IMPORT_NAME              0 (os.path)
              9 STORE_NAME               1 (os)
             12 LOAD_CONST               1 (None)
             15 RETURN_VALUE
&amp;gt;&amp;gt;&amp;gt; dis.disassemble(compile(&#39;import os.path as os_path&#39;, &#39;&#39;, &#39;exec&#39;))
  1           0 LOAD_CONST               0 (-1)
              3 LOAD_CONST               1 (None)
              6 IMPORT_NAME              0 (os.path)
              9 LOAD_ATTR                1 (path)
             12 STORE_NAME               2 (os_path)
             15 LOAD_CONST               1 (None)
             18 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前者では &lt;code&gt;IMPORT_NAME os.path&lt;/code&gt; でロードされたモジュールを &lt;code&gt;os&lt;/code&gt; という名前でシンボルテーブルに登録する。では、&lt;code&gt;IMPORT_NAME os.path&lt;/code&gt; でロードされるモジュールは何かといえば、これは &lt;a href=&#34;http://docs.python.org/lib/module-os.html&#34;&gt;os&lt;/a&gt; モジュールである。&lt;a href=&#34;http://docs.python.org/lib/module-os.path.html&#34;&gt;os.path&lt;/a&gt; ではない。&lt;/p&gt;

&lt;p&gt;そして、&lt;em&gt;os&lt;/em&gt; モジュール内部では &lt;em&gt;os.path&lt;/em&gt; モジュールを &lt;code&gt;path&lt;/code&gt; という名前でインポートしている（実際には、プラットフォームごとに異なるモジュールをインポートする）。そのため、&lt;em&gt;os&lt;/em&gt; モジュールを &lt;code&gt;os&lt;/code&gt; という名前でシンボルテーブルに登録しておけば、&lt;code&gt;os.path&lt;/code&gt; で &lt;em&gt;os.path&lt;/em&gt; モジュールを参照できるわけだ（このへんは次節で更に掘り下げる）。&lt;/p&gt;

&lt;p&gt;それにたいして、後者の &lt;code&gt;import os.path as os_path&lt;/code&gt; では &lt;code&gt;IMPORT_NAME os.path&lt;/code&gt; でロードされたモジュールから &lt;code&gt;LOAD_ATTR path&lt;/code&gt; で取り出した &lt;em&gt;os.path&lt;/em&gt; モジュールを &lt;code&gt;os_path&lt;/code&gt; という名前でシンボルテーブルに登録する。このように、&lt;code&gt;import &amp;lt;module&amp;gt;&lt;/code&gt; と &lt;code&gt;import &amp;lt;module&amp;gt; as &amp;lt;name&amp;gt;&lt;/code&gt; では、実行時の振る舞いが微妙に異なっている。&lt;/p&gt;

&lt;h3 id=&#34;import-a-と-import-a-b&#34;&gt;import A と import A.B&lt;/h3&gt;

&lt;p&gt;ここからはバイトコードを離れて、&lt;code&gt;import&lt;/code&gt; の動作をみていこう。まずは前節の&lt;code&gt;import os.path as os_path&lt;/code&gt; を振り返る。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;IMPORT_NAME os.path&lt;/code&gt; で &lt;em&gt;os&lt;/em&gt; モジュールがロードされる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOAD_ATTR path&lt;/code&gt; で &lt;em&gt;os&lt;/em&gt; モジュールから &lt;em&gt;os.path&lt;/em&gt; モジュールを取り出す&lt;/li&gt;
&lt;li&gt;取り出した &lt;em&gt;os.path&lt;/em&gt; モジュールを &lt;code&gt;os_path&lt;/code&gt; という名前でシンボルテーブルに登録する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前節でも書いたように、&lt;em&gt;os&lt;/em&gt; モジュール内部では &lt;em&gt;os.path&lt;/em&gt; モジュールを &lt;code&gt;path&lt;/code&gt; という名前でインポートしているので、2. の手順がうまくいくのは納得できる。しかし、それ以外のモジュール（パッケージ）ではどうだろうか？&lt;/p&gt;

&lt;p&gt;たとえば、&lt;strong&gt;A.B.C&lt;/strong&gt; というパッケージ構造があるとする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% python
&amp;gt;&amp;gt;&amp;gt; import A
&amp;gt;&amp;gt;&amp;gt; A
&amp;lt;module &#39;A&#39; from &#39;A/__init__.pyc&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; dir(A)
[&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;, &#39;__path__&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように、&lt;code&gt;dir()&lt;/code&gt; で調べても、&lt;em&gt;A&lt;/em&gt; モジュールに &lt;code&gt;B&lt;/code&gt; という属性はない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; A.B
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
AttributeError: &#39;module&#39; object has no attribute &#39;B&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということは、このパッケージでは &lt;code&gt;import A.B as A_B&lt;/code&gt; のようなインポートは失敗しそうだ。何故なら &lt;em&gt;A&lt;/em&gt; モジュールに &lt;code&gt;B&lt;/code&gt; という属性はないのだから、上の手順では 2. で失敗するはずである。&lt;/p&gt;

&lt;p&gt;まずは念のため、バイトコードも確認しておこう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dis.disassemble(compile(&#39;import A.B as A_B&#39;, &#39;&#39;, &#39;exec&#39;))
  1           0 LOAD_CONST               0 (-1)
              3 LOAD_CONST               1 (None)
              6 IMPORT_NAME              0 (A.B)
              9 LOAD_ATTR                1 (B)
             12 STORE_NAME               2 (A_B)
             15 LOAD_CONST               1 (None)
             18 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前節でみたものと同じだ。やはり、&lt;code&gt;LOAD_ATTR&lt;/code&gt; で &lt;code&gt;B&lt;/code&gt; を取り出そうとしている。では、実行してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import A.B as A_B
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おかしい。成功してしまった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; A_B
&amp;lt;module &#39;A.B&#39; from &#39;A/B/__init__.pyc&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんとインポートもできているようだ。どういうことだろうか？　一旦インタプリタを終了して、もう一度、今度は &lt;code&gt;import A.B&lt;/code&gt; を試してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% python
&amp;gt;&amp;gt;&amp;gt; import A.B
&amp;gt;&amp;gt;&amp;gt; A.B
&amp;lt;module &#39;A.B&#39; from &#39;A/B/__init__.pyc&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんと、&lt;code&gt;A.B&lt;/code&gt; でモジュールにアクセスできている。更に &lt;code&gt;import A&lt;/code&gt; して &lt;em&gt;A&lt;/em&gt; モジュールを調べてみると、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import A
&amp;gt;&amp;gt;&amp;gt; A
&amp;lt;module &#39;A&#39; from &#39;A/__init__.pyc&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; dir(A)
[&#39;B&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;, &#39;__path__&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;A&lt;/em&gt; モジュールに &lt;code&gt;B&lt;/code&gt; が増えていることが分かる。&lt;/p&gt;

&lt;p&gt;これで &lt;em&gt;os&lt;/em&gt; 以外のモジュールでも &lt;code&gt;import&lt;/code&gt; がうまく動作する理由が分かった。おそらくは &lt;code&gt;IMPORT_NAME&lt;/code&gt; が実行されるときに、内部的にこのような下準備が行われていたわけだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python の dis モジュールでさまざまな import 文を disassemble する</title>
      <link>http://www.metareal.org/2008/09/25/disassembling-python-import-statements/</link>
      <pubDate>Thu, 25 Sep 2008 09:34:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/09/25/disassembling-python-import-statements/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://docs.python.org/ref/&#34;&gt;Python Reference Manual&lt;/a&gt; の &lt;a href=&#34;http://docs.python.org/ref/import.html&#34;&gt;6.12 The import statement&lt;/a&gt; を参考に、さまざまな形式の import 文を &lt;a href=&#34;http://docs.python.org/lib/module-dis.html&#34;&gt;dis&lt;/a&gt; モジュールで &lt;code&gt;disassemble&lt;/code&gt; してみた。&lt;/p&gt;

&lt;h3 id=&#34;import&#34;&gt;import &amp;hellip;&lt;/h3&gt;

&lt;p&gt;まずは、もっとも単純な &lt;code&gt;import ...&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dis.disassemble(compile(&#39;import os&#39;, &#39;&#39;, &#39;exec&#39;))
  1           0 LOAD_CONST               0 (-1)
              3 LOAD_CONST               1 (None)
              6 IMPORT_NAME              0 (os)
              9 STORE_NAME               0 (os)
             12 LOAD_CONST               1 (None)
             15 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;IMPORT_NAME&lt;/code&gt; で &lt;code&gt;import&lt;/code&gt; するモジュールが指定されていることが分かる。では、&lt;code&gt;as&lt;/code&gt; を使って別名をつけるとどうなるだろうか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dis.disassemble(compile(&#39;import os as os2&#39;, &#39;&#39;, &#39;exec&#39;))
  1           0 LOAD_CONST               0 (-1)
              3 LOAD_CONST               1 (None)
              6 IMPORT_NAME              0 (os)
              9 STORE_NAME               1 (os2)
             12 LOAD_CONST               1 (None)
             15 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;STORE_NAME&lt;/code&gt; の引数が &lt;code&gt;os&lt;/code&gt; から &lt;code&gt;os2&lt;/code&gt; に変わった。つまり、登録するシンボル名は &lt;code&gt;STORE_NAME&lt;/code&gt; で指定されるということだろう。&lt;/p&gt;

&lt;h3 id=&#34;import-1&#34;&gt;import &amp;hellip;, &amp;hellip;&lt;/h3&gt;

&lt;p&gt;複数のモジュールを &lt;code&gt;import&lt;/code&gt; してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dis.disassemble(compile(&#39;import os, sys&#39;, &#39;&#39;, &#39;exec&#39;))
  1           0 LOAD_CONST               0 (-1)
              3 LOAD_CONST               1 (None)
              6 IMPORT_NAME              0 (os)
              9 STORE_NAME               0 (os)
             12 LOAD_CONST               0 (-1)
             15 LOAD_CONST               1 (None)
             18 IMPORT_NAME              1 (sys)
             21 STORE_NAME               1 (sys)
             24 LOAD_CONST               1 (None)
             27 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特別なバイトコードが用意されているわけではなく、引数だけが異なるバイトコードが繰り返されるようだ。&lt;/p&gt;

&lt;h3 id=&#34;from-import&#34;&gt;from &amp;hellip; import &amp;hellip;&lt;/h3&gt;

&lt;p&gt;モジュールから特定のシンボルだけを &lt;code&gt;import&lt;/code&gt; する &lt;code&gt;from ... import ...&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dis.disassemble(compile(&#39;from os.path import join&#39;, &#39;&#39;, &#39;exec&#39;))
  1           0 LOAD_CONST               0 (-1)
              3 LOAD_CONST               1 ((&#39;join&#39;,))
              6 IMPORT_NAME              0 (os.path)
              9 IMPORT_FROM              1 (join)
             12 STORE_NAME               1 (join)
             15 POP_TOP
             16 LOAD_CONST               2 (None)
             19 RETURN_VALUE

&amp;gt;&amp;gt;&amp;gt; dis.disassemble(compile(&#39;from os.path import join, dirname&#39;, &#39;&#39;, &#39;exec&#39;))
  1           0 LOAD_CONST               0 (-1)
              3 LOAD_CONST               1 ((&#39;join&#39;, &#39;dirname&#39;))
              6 IMPORT_NAME              0 (os.path)
              9 IMPORT_FROM              1 (join)
             12 STORE_NAME               1 (join)
             15 IMPORT_FROM              2 (dirname)
             18 STORE_NAME               2 (dirname)
             21 POP_TOP
             22 LOAD_CONST               2 (None)
             25 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新しく &lt;code&gt;IMPORT_FROM&lt;/code&gt; が登場しているが、基本的な構造は変わらない。&lt;/p&gt;

&lt;p&gt;すこし特殊なのが &lt;code&gt;from ... import *&lt;/code&gt; でモジュール内のすべてのシンボルを &lt;code&gt;import&lt;/code&gt; する場合だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dis.disassemble(compile(&#39;from module import *&#39;, &#39;&#39;, &#39;exec&#39;))
  1           0 LOAD_CONST               0 (-1)
              3 LOAD_CONST               1 ((&#39;*&#39;,))
              6 IMPORT_NAME              0 (module)
              9 IMPORT_STAR
             10 LOAD_CONST               2 (None)
             13 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;STORE_NAME&lt;/code&gt; がなくなり、専用の &lt;code&gt;IMPORT_STAR&lt;/code&gt; が使われている。&lt;/p&gt;

&lt;h3 id=&#34;relative-imports&#34;&gt;Relative Imports&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.python.org/whatsnew/pep-328.html&#34;&gt;相対インポート&lt;/a&gt;はどのように実現されているのだろう？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dis.disassemble(compile(&#39;from .. b import B&#39;, &#39;&#39;, &#39;exec&#39;))
  1           0 LOAD_CONST               0 (2)
              3 LOAD_CONST               1 ((&#39;B&#39;,))
              6 IMPORT_NAME              0 (b)
              9 IMPORT_FROM              1 (B)
             12 STORE_NAME               1 (B)
             15 POP_TOP
             16 LOAD_CONST               2 (None)
             19 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一見すると、&lt;code&gt;from b import B&lt;/code&gt; から変わったところは見当たらない。しかし、最初の &lt;code&gt;LOAD_CONST&lt;/code&gt; に注目してほしい。いままで &lt;code&gt;-1&lt;/code&gt; だった引数が 2 になっている。ここで相対インポートの深さを指定しているわけだ。&lt;/p&gt;

&lt;h3 id=&#34;from-future-import&#34;&gt;from &lt;strong&gt;future&lt;/strong&gt; import &amp;hellip;&lt;/h3&gt;

&lt;p&gt;最後に &lt;code&gt;from __future__&lt;/code&gt; がどのようにコンパイルされるのか見ておこう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dis.disassemble(compile(&#39;from __future__ import absolute_import&#39;, &#39;&#39;, &#39;exec&#39;))
  1           0 LOAD_CONST               0 (0)
              3 LOAD_CONST               1 ((&#39;absolute_import&#39;,))
              6 IMPORT_NAME              0 (__future__)
              9 IMPORT_FROM              1 (absolute_import)
             12 STORE_NAME               1 (absolute_import)
             15 POP_TOP
             16 LOAD_CONST               2 (None)
             19 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バイトコードは普通の &lt;code&gt;import&lt;/code&gt; と変わらないように見える。&lt;/p&gt;

&lt;p&gt;それもそのはずで、実行時の振る舞いは通常の &lt;code&gt;import&lt;/code&gt; と同じなのだ。もちろん、コンパイル時はコンパイラが &lt;code&gt;from __future__&lt;/code&gt; を特別扱いしてセマンティクスのチェックなどを行うわけだが、&lt;strong&gt;実行時は標準ライブラリの &lt;strong&gt;future&lt;/strong&gt;.py を import するようになっている&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.metareal.org/2008/09/25/disassembling-python-import-statements-take2/&#34;&gt;追記が長くなったので、つづきを別の記事として書きました&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python.org/ref/import.html&#34;&gt;6.12 The import statement&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python.org/ref/future.html&#34;&gt;6.12.1 Future statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python.org/lib/module-dis.html&#34;&gt;dis &amp;ndash; Disassembler for Python byte code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python.org/lib/bytecodes.html&#34;&gt;Python Byte Code Instructions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.python.org/dev/peps/pep-0236/&#34;&gt;PEP 236 &amp;ndash; Back to the &lt;strong&gt;future&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Python でプロパティリストを読み込む</title>
      <link>http://www.metareal.org/2008/08/04/propertylist-parser-for-python/</link>
      <pubDate>Tue, 05 Aug 2008 12:21:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/08/04/propertylist-parser-for-python/</guid>
      <description>

&lt;p&gt;Python で&lt;a href=&#34;http://ja.wikipedia.org/wiki/プロパティリスト&#34;&gt;プロパティリスト&lt;/a&gt;を読み込み、オブジェクトに変換するライブラリ &lt;a href=&#34;http://github.com/ishikawa/python-plist-parser/&#34;&gt;plist_parser&lt;/a&gt; を書いた。&lt;a href=&#34;http://github.com/ishikawa&#34;&gt;GitHub&lt;/a&gt; で&lt;a href=&#34;http://github.com/ishikawa/python-plist-parser/&#34;&gt;公開している&lt;/a&gt;。Python 2.4 以降で動作確認済み。ただし、対応するフォーマットは XML のみで、書き込みにも対応していない。&lt;/p&gt;

&lt;p&gt;使い方は至って単純だ。たとえば、以下のプロパティリストは &lt;code&gt;iTunes Music Library.xml&lt;/code&gt; から一部抜粋したものだが、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
  &amp;lt;key&amp;gt;Track ID&amp;lt;/key&amp;gt;
  &amp;lt;integer&amp;gt;4154&amp;lt;/integer&amp;gt;
  &amp;lt;key&amp;gt;Artist&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;Megadeth&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;Name&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;Architecture Of Aggression&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;Date Added&amp;lt;/key&amp;gt;
  &amp;lt;date&amp;gt;2008-06-23T12:20:17Z&amp;lt;/date&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このプロパティリストが &lt;code&gt;music.xml&lt;/code&gt; という名前で保存されているとして、このファイルを読み込んでオブジェクトに変換するコードは以下のとおり。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from plist_parser import XmlPropertyListParser, \
                         PropertyListParseError

f = open(&#39;music.plist&#39;)
try:
    print XmlPropertyListParser().parse(f)
    # =&amp;gt;
    # {
    #    &#39;Date Added&#39;: datetime.datetime(2008, 6, 23, 12, 20, 17),
    #    &#39;Track ID&#39;: 4154,
    #    &#39;Name&#39;: &#39;Architecture Of Aggression&#39;,
    #    &#39;Artist&#39;: &#39;Megadeth&#39;
    # }
except PropertyListParseError:
    raise
finally:
    f.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特に説明の必要はないだろう。&lt;/p&gt;

&lt;p&gt;自作ライブラリの紹介はこれくらいにし、以降では、&lt;strong&gt;Python でプロパティリストを解析する他の手段&lt;/strong&gt;と、それらのパフォーマンスを比較した結果について書いてみたい。&lt;/p&gt;

&lt;h3 id=&#34;plistlib&#34;&gt;plistlib&lt;/h3&gt;

&lt;p&gt;Python 2.6 からは、プロパティリストの読み書きをするためのライブラリ &lt;a href=&#34;http://docs.python.org/dev/library/plistlib.html&#34;&gt;plistlib&lt;/a&gt; が標準で添付されている。また、Python 2.5 以前でもソースコードや Mac 向けのディストリビューションには含まれているので、実はプロパティリストを読み込みたいだけなら、今回自作した &lt;a href=&#34;http://github.com/ishikawa/python-plist-parser/&#34;&gt;plist_parser&lt;/a&gt; の有用性はすくない。&lt;/p&gt;

&lt;p&gt;それなら、何故わざわざ自作したのかといえば、ほぼ実装してしまってから &lt;a href=&#34;http://docs.python.org/dev/library/plistlib.html&#34;&gt;plistlib&lt;/a&gt; の存在に気づいたのだ。勘弁してほしい。&lt;/p&gt;

&lt;h3 id=&#34;xml-etree&#34;&gt;xml.etree&lt;/h3&gt;

&lt;p&gt;Python 2.5 から標準添付されている &lt;a href=&#34;http://docs.python.org/lib/module-xml.etree.ElementTree.html&#34;&gt;xml.etree&lt;/a&gt; ライブラリを使うと XML の処理が簡潔に記述できる。作者のサイト &lt;a href=&#34;http://effbot.org/&#34;&gt;effbot.org&lt;/a&gt; に掲載されている記事 &lt;a href=&#34;http://effbot.org/zone/element-iterparse.htm&#34;&gt;The ElementTree iterparse Function&lt;/a&gt; に、ちょうど、このライブラリを使ってプロパティリストを読み込む例がある（以下はすこし改変してある）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from xml.etree.ElementTree import iterparse
import base64, datetime, re

unmarshallers = {

    # collections
    &amp;quot;array&amp;quot;: lambda x: [v.text for v in x],
    &amp;quot;dict&amp;quot;: lambda x:
        dict((x[i].text, x[i+1].text) for i in range(0, len(x), 2)),
    &amp;quot;key&amp;quot;: lambda x: x.text or &amp;quot;&amp;quot;,

    # simple types
    &amp;quot;string&amp;quot;: lambda x: x.text or &amp;quot;&amp;quot;,
    &amp;quot;data&amp;quot;: lambda x: base64.decodestring(x.text or &amp;quot;&amp;quot;),
    &amp;quot;date&amp;quot;: lambda x: datetime.datetime(*map(int, re.findall(&amp;quot;\d+&amp;quot;, x.text))),
    &amp;quot;true&amp;quot;: lambda x: True,
    &amp;quot;false&amp;quot;: lambda x: False,
    &amp;quot;real&amp;quot;: lambda x: float(x.text),
    &amp;quot;integer&amp;quot;: lambda x: int(x.text),

}

def load(file):
    parser = iterparse(file)
    for action, elem in parser:
        unmarshal = unmarshallers.get(elem.tag)
        if unmarshal:
            data = unmarshal(elem)
            elem.clear()
            elem.text = data
        elif elem.tag != &amp;quot;plist&amp;quot;:
            raise IOError(&amp;quot;unknown plist type: %r&amp;quot; % elem.tag)
    return parser.root[0].text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非常にコンパクトだ。&lt;/p&gt;

&lt;p&gt;xml.etree は C による実装 &lt;code&gt;xml.etree.cElementTree&lt;/code&gt; も提供されており、これを使うとパフォーマンスでもかなりの好成績を出すようになる（具体的なパフォーマンスの比較は後述）。&lt;/p&gt;

&lt;h3 id=&#34;パフォーマンスの比較&#34;&gt;パフォーマンスの比較&lt;/h3&gt;

&lt;p&gt;さて、プロパティリストを読み込むためのライブラリとして、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://github.com/ishikawa/python-plist-parser/&#34;&gt;plist_parser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python.org/dev/library/plistlib.html&#34;&gt;plistlib&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python.org/lib/module-xml.etree.ElementTree.html&#34;&gt;xml.etree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の三つが出揃った。これらのパフォーマンスを比較してみよう。&lt;/p&gt;

&lt;p&gt;それぞれのライブラリを使用したプログラムを用意する。測定対象のプログラムはどれも、iTunes の音楽ライブラリのプロパティリスト（約 7MB）を読み込み、オブジェクトに変換する、というものである。&lt;strong&gt;これらのプログラムをそれぞれ 20 回ずつ実行し、その実行時間の平均を比較する&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;また、プログラムと測定方法については、以下の点にも気をつけた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IO の影響をすくなくするため、ファイルはあらかじめメモリに展開する&lt;/li&gt;
&lt;li&gt;メモリ管理の影響をすくなくするため、プログラムの実行中は GC を停止する（C プログラムの場合は、メモリを解放しない）&lt;/li&gt;
&lt;li&gt;負荷の高いバックグラウンドプロセス（たとえば &lt;a href=&#34;http://www.apple.com/jp/macosx/features/timemachine.html&#34;&gt;Time Machine&lt;/a&gt; など）はオフにする&lt;/li&gt;
&lt;li&gt;ウォームアップのために、事前にプログラムを 5 回実行する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;しかし、実行時間はプログラムを実行するコンピューターの性能に左右される。誰かのコンピューターで 5 秒しかかからなかった、と言われても、あなたにとっては意味がないだろう。それぞれのプログラムの実行時間を並べていっても、実際にどれくらい速いのか（あるいは、遅いのか）はわかりづらい。基準となる比較対象が必要だ。&lt;/p&gt;

&lt;p&gt;今回は比較対象として、&lt;a href=&#34;http://github.com/ishikawa/python-plist-parser/tree/master/tools/performance/core_foundation_parser.c&#34;&gt;C による実装&lt;/a&gt;を用意した。これは Mac OS X ネイティブの API を使って、プロパティリストを読み込んでいる。&lt;strong&gt;このプログラムの実行時間を 1 として、それぞれの実行時間を比較&lt;/strong&gt;してみよう（なお、測定に使用したプログラムは&lt;a href=&#34;http://github.com/ishikawa/python-plist-parser/tree/master/tools/performance/profiler.py&#34;&gt;ここに置いてある&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.flickr.com/photos/ishikawa_takanori/2732221848/&#34;&gt;&lt;img src=&#34;http://farm4.static.flickr.com/3123/2732221848_38f2439737_o.png&#34; alt=&#34;Performance of Python Property Lists Libraries&#34; /&gt;&lt;/a&gt;やはり、C によるプログラムが桁違いに速い。ちなみに、実時間でいえば 0.5 秒程度である。&lt;/p&gt;

&lt;p&gt;次に目立つのが &lt;a href=&#34;http://docs.python.org/lib/module-xml.etree.ElementTree.html&#34;&gt;xml.etree&lt;/a&gt; によるプログラムだ。これは C による &lt;code&gt;xml.etree.cElementTree&lt;/code&gt; と Python のみで実装された &lt;code&gt;xml.etree.ElementTree&lt;/code&gt; のふたつがあるが、&lt;code&gt;xml.etree.cElementTree&lt;/code&gt; はかなり速いことがわかる。C によるプログラムと比較しても 5 倍程度の実行時間、&lt;a href=&#34;http://docs.python.org/dev/library/plistlib.html&#34;&gt;plistlib&lt;/a&gt; と比較すると 3 倍程度速く、優秀であるといえる。逆に、Python による実装の &lt;code&gt;xml.etree.ElementTree&lt;/code&gt; がズバ抜けて遅いのも興味深い。&lt;/p&gt;

&lt;p&gt;ところで、グラフからも分かるように、&lt;code&gt;plist_parser&lt;/code&gt; には実装がふたつある。&lt;/p&gt;

&lt;p&gt;実は、今回の測定で &lt;code&gt;xml.etree.cElementTree&lt;/code&gt; が速いことが判り、&lt;code&gt;xml.etree.cElementTree&lt;/code&gt; がインストールされているときはそちらを使うように急遽作りかえたのだ（ない場合は、&lt;code&gt;xml.sax&lt;/code&gt; による実装を使う）。&lt;/p&gt;

&lt;p&gt;そのため、Python 2.5 以降など、&lt;code&gt;xml.etree.cElementTree&lt;/code&gt; がインストールされている環境では、同程度の速度で動作するようになっている。&lt;/p&gt;

&lt;h3 id=&#34;最後に&#34;&gt;最後に&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;XML を扱うなら、&lt;a href=&#34;http://docs.python.org/lib/module-xml.etree.ElementTree.html&#34;&gt;xml.etree&lt;/a&gt; は一見の価値あり&lt;/li&gt;
&lt;li&gt;ライブラリを作るまえに、同じものがすでにないかチェックした方がよい&lt;/li&gt;
&lt;li&gt;パフォーマンスを測定するのは難しい&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Google App Engine への移行</title>
      <link>http://www.metareal.org/2008/05/20/porting-weblog-to-google-app-engine/</link>
      <pubDate>Tue, 20 May 2008 07:39:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/05/20/porting-weblog-to-google-app-engine/</guid>
      <description>

&lt;p&gt;ここ数日というもの、Mac の前に座ってやっていたことといえば、&lt;a href=&#34;http://twitter.com/takanori_is&#34;&gt;Twitter&lt;/a&gt; か RSS フィードの消化か、でなければブログの移行作業だ。&lt;/p&gt;

&lt;p&gt;もともと、このブログは &lt;a href=&#34;http://wordpress.org/&#34;&gt;Wordpress&lt;/a&gt; で運営していたのだが、色々と不満もたまってきたので、いつの日かつくりなおしたい、と思っていた。おりしも &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; の勉強をはじめたばかりである。ちょうどよい。教材代わりに簡単なブログシステムを細々とつくっていた。&lt;/p&gt;

&lt;p&gt;それを更に、&lt;a href=&#34;http://code.google.com/appengine/&#34;&gt;Google App Engine&lt;/a&gt; に移植しましたよ、というのが今回のお話。&lt;/p&gt;

&lt;h3 id=&#34;google-app-engine-に移植した理由&#34;&gt;Google App Engine に移植した理由&lt;/h3&gt;

&lt;p&gt;まずは、Google App Engine（以下、GAE）に移植した理由から説明させてほしい。いままで Wordpress を動かしていたサーバでそのまま新しいブログシステムを動かすこともできた。&lt;/p&gt;

&lt;p&gt;それでも、わざわざ時間を割いてまで GAE に移植したのは、GAE が話題になってるとか、Django が使えるらしい、というのも重要だったが、&lt;strong&gt;自宅サーバの管理から解放されたい&lt;/strong&gt; 、という理由が実は一番大きい。&lt;/p&gt;

&lt;p&gt;うん、自宅サーバの、しかも個人ブログの管理の手間なんて、たかがしれている（そりゃ、セキュリティとかは神経使うけどさ）。それよりは今後、もし、転居や契約している回線業者を変更する場合を考えると、そのあいだは自宅サーバは停めなきゃならないわけで、いまのうちに GAE に移植しておけば、あとあと困らないだろう、というわけである。&lt;/p&gt;

&lt;p&gt;実際の移植作業には 4 日程度を要した。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://code.google.com/appengine/docs/&#34;&gt;GAE のオンラインドキュメント&lt;/a&gt; を参考に、ほとんど単純作業による変換だったが、細かい変更や思わぬ問題などもあったので、開発中にとったメモを片手につらつらと書いてみる。&lt;/p&gt;

&lt;h3 id=&#34;django&#34;&gt;Django&lt;/h3&gt;

&lt;p&gt;Django は &lt;a href=&#34;http://code.google.com/appengine/articles/django.html&#34;&gt;Running Django on Google App Engine&lt;/a&gt; を参考に、開発版のものを動かしている。&lt;/p&gt;

&lt;p&gt;GAE では Django の &lt;a href=&#34;http://www.djangoproject.com/documentation/db-api/&#34;&gt;Database API&lt;/a&gt;（&lt;a href=&#34;http://ymasuda.jp/python/django/docs/db-api.html&#34;&gt;和訳&lt;/a&gt;）は動作せず、GAE の &lt;a href=&#34;http://code.google.com/appengine/docs/datastore/&#34;&gt;Datastore API&lt;/a&gt; を使う必要があるが、当然の帰結として、Database API に依存した機能やアドオンも使えない。Django の売りのひとつである &lt;a href=&#34;http://www.djangobook.com/en/1.0/chapter06/&#34;&gt;Admin Interface&lt;/a&gt; も、サイトマップを手軽に生成できる &lt;a href=&#34;http://www.djangoproject.com/documentation/sitemaps/&#34;&gt;Sitemap framework&lt;/a&gt; も、&lt;a href=&#34;http://www.djangoproject.com/documentation/generic_views/&#34;&gt;Generic View&lt;/a&gt; でさえ使えない。また、Sites も &lt;a href=&#34;http://www.djangoproject.com/documentation/sites/#requestsite-objects&#34;&gt;RequestSite オブジェクトで代替&lt;/a&gt;してやらなくてはいけない。&lt;/p&gt;

&lt;p&gt;ただ、Generic View は簡単な変更で動きそうだ。実際、&lt;a href=&#34;http://www.djangoproject.com/documentation/pagination/&#34;&gt;Pagination&lt;/a&gt; の処理では &lt;code&gt;django.core.QuerySetPaginator&lt;/code&gt; に GAE の &lt;a href=&#34;http://code.google.com/appengine/docs/datastore/queryclass.html&#34;&gt;Query&lt;/a&gt; オブジェクトをそのまま渡して動作していた（GAE の Query オブジェクトも &lt;code&gt;[]&lt;/code&gt; アクセスを適切な &lt;code&gt;fetch()&lt;/code&gt; に変換してくれる）。&lt;/p&gt;

&lt;h3 id=&#34;akismet&#34;&gt;Akismet&lt;/h3&gt;

&lt;p&gt;スパムコメント対策として &lt;a href=&#34;http://www.hashcash.org/&#34;&gt;Hashcash&lt;/a&gt; と &lt;a href=&#34;http://akismet.com/&#34;&gt;Akismet&lt;/a&gt; を使っているのだが、外部リソースへのアクセスは GAE の &lt;a href=&#34;http://code.google.com/appengine/docs/urlfetch/&#34;&gt;URL Fetch API&lt;/a&gt; に変更が必要だ。Akismet への問い合わせ処理は、外部リソースへのアクセスなので URL Fetch API を使うように変更が必要だった。&lt;/p&gt;

&lt;h3 id=&#34;docutils-pygments&#34;&gt;docutils, pygments&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docutils.sourceforge.net/rst.html&#34;&gt;reStructuredText&lt;/a&gt; でブログを書くために &lt;a href=&#34;http://docutils.sourceforge.net/&#34;&gt;docutils&lt;/a&gt; を、そして、ソースコードのハイライトするために &lt;a href=&#34;http://pygments.org/&#34;&gt;pygments&lt;/a&gt; をソースコードに含めるようにした（トップレベルだと邪魔なので、&lt;code&gt;lib&lt;/code&gt; というディレクトリにパスを通して、そこに必要なライブラリを置くようにした）。&lt;/p&gt;

&lt;p&gt;また、docutils はそのままだと、一部 GAE で禁止されているファイルシステム関連の API を使っている。&lt;code&gt;docutils/frontend.py&lt;/code&gt; の&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if read_config_files and not self.defaults[&#39;_disable_config&#39;]:
    try:
        config_settings = self.get_standard_config_settings()
    except ValueError, error:
        self.error(error)
    self.set_defaults(**config_settings.__dict__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この部分は潔くコメントアウトした。&lt;/p&gt;

&lt;h3 id=&#34;検索機能&#34;&gt;検索機能&lt;/h3&gt;

&lt;p&gt;モデルクラスで db.Model ではなく、そのサブクラスである google.appengine.ext.search.SearchableModel を継承することで、モデルの検索ができるようになるようだ（&lt;a href=&#34;http://groups.google.com/group/google-appengine/browse_thread/thread/ba4a4a4ccefb96c5/0e3f0ab63c4c8afd&#34;&gt;Indexing Large Chunks of Text for Search - Google App Engine | Google グループ&lt;/a&gt; を参照）。「検索機能を備えたクラスを継承する」というだけでもダサいのに、日本語での使用とか不安なので、検索機能はとりあえず見送った。&lt;/p&gt;

&lt;h3 id=&#34;デプロイして直面した問題&#34;&gt;デプロイして直面した問題&lt;/h3&gt;

&lt;p&gt;Web アプリケーションの宿命で、最大の問題はデプロイ後にやってくる。&lt;/p&gt;

&lt;p&gt;デプロイ直後はすぐに CPU 制限にひっかかってしまう
理由は分からないが、デプロイ直後は GAE の CPU 制限によるエラーが頻発した。これくらいの処理でもういっぱいなのか、と萎えかけたが、しばらくすると正常に動作するようになった。なので、これからもし、同じ現象に遭われた方は、静かな心で見守るのがよいと思う。&lt;/p&gt;

&lt;p&gt;データベースの制限でデータ移行ができない
以前のブログからのデータ移行は、dump したデータベースからデータを投入する Python スクリプトを生成する移行スクリプトを用意していた（&lt;a href=&#34;http://code.google.com/appengine/articles/bulkload.html&#34;&gt;CSV を使う手段&lt;/a&gt;もあるようだが、こっちの方がオブジェクト間の関連を再現するのも楽だ）。&lt;/p&gt;

&lt;p&gt;しかし、&lt;strong&gt;これが動かない&lt;/strong&gt;。一度に保存するデータが多すぎると制限にひっかかってエラーになるらしい。&lt;/p&gt;

&lt;p&gt;解決策としては、移行処理を機械的に関数に分割して、一度のリクエストでひとつの関数を呼ぶように変更、外部からスクリプトで順番にアクセスさせるようにした。現実の素晴らしき泥臭さ。&lt;/p&gt;

&lt;p&gt;favicon.ico と robots.txt の設定
些細なことかもしれないが、favicon.ico と robots.txt の設定をしていなかったせいで、404 エラーが大量に発生してしまった。&lt;a href=&#34;http://d.hatena.ne.jp/technohippy/20080412#1207983599&#34;&gt;Google App Engineでfaviconを設定する&lt;/a&gt;を参考に &lt;code&gt;app.yaml&lt;/code&gt; を設定した。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- url: /favicon.ico
  static_files: public/favicon.ico
  upload: public/favicon\.ico
- url: (.*?)/robots.txt
  static_files: public/robots.txt
  upload: public/robots\.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;gae-にしてよかったこと-不満&#34;&gt;GAE にしてよかったこと・不満&lt;/h3&gt;

&lt;p&gt;最後に感想でも。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;デプロイも管理も楽&lt;/li&gt;
&lt;li&gt;思ったよりも速い&lt;/li&gt;
&lt;li&gt;独自ドメインの設定も簡単だった&lt;/li&gt;
&lt;li&gt;ログの管理や分析とか見過ごしがちな点でもあるので地味に助かる&lt;/li&gt;
&lt;li&gt;管理インターフェースはまだまだ（特に Django の管理インターフェースを期待していた身としてはつらい）&lt;/li&gt;
&lt;li&gt;ひとつの閉じた世界をいじくってる楽しさがある&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最後の点について補足。必要なライブラリはバンドルしなければならないが、それ以外の部分（サーバ管理とか、ミドルウェアとか、ログとか）は無視してアプリケーションの開発に集中できる、という意味で「ひとつの閉じた世界をいじくってる楽しさ」を感じた。そういうこと。&lt;/p&gt;

&lt;p&gt;あと 2 つアプリケーション作れるらしいので、何かネタを思いついたら挑戦してみたいですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Django の urlresolvers.py を読む</title>
      <link>http://www.metareal.org/2008/04/22/django-code-reading-core-urlresolvers/</link>
      <pubDate>Tue, 22 Apr 2008 10:38:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/04/22/django-code-reading-core-urlresolvers/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://lifecoding.metareal.org/post/32387415&#34;&gt;一身上の都合&lt;/a&gt;により &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; の &lt;a href=&#34;http://www.djangoproject.com/documentation/url_dispatch/&#34;&gt;URL dispatcher&lt;/a&gt; について調べている。ドキュメントでだいたいの動作は把握したので、今回は &lt;code&gt;urls.py&lt;/code&gt; に定義した URL のマッピングが実際にはどのように解決されているのか、ソースコードを読むことで理解を深めたい、と思う。&lt;/p&gt;

&lt;p&gt;なお、参照したソースコードは SVN の Revision 7438 である。公開リリースの 0.96.1 とは内容が大きく異なる可能性があること、 &lt;a href=&#34;http://code.djangoproject.com/query&#34;&gt;Trac&lt;/a&gt; での議論やドキュメントを読むかぎり、このへんの実装については今後大きく変更されるかもしれないことを、あらかじめお断りしておく。&lt;/p&gt;

&lt;h3 id=&#34;urlresolvers-py&#34;&gt;urlresolvers.py&lt;/h3&gt;

&lt;p&gt;まずは、調べるソースコードを特定しよう。URL の逆マッピングをしてくれる &lt;a href=&#34;http://www.djangoproject.com/documentation/url_dispatch/#reverse&#34;&gt;reverse() 関数&lt;/a&gt;が用意されていることは分かっているので、これを手がかりにソースコードを探すのがよさそうだ。&lt;/p&gt;

&lt;p&gt;試しに &lt;code&gt;def reverse(&lt;/code&gt; を検索してみると、簡単に見つかった。&lt;code&gt;django/core/urlresolvers.py&lt;/code&gt; で定義されている。ソースコードのコメントにも、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This module converts requested URLs to callback view functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;と書かれているので、これが探していたソースコード（モジュール）だろう。&lt;/p&gt;

&lt;h3 id=&#34;reverse-と-resolve&#34;&gt;reverse() と resolve()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;urlresolvers.py&lt;/code&gt; では &lt;code&gt;reverse()&lt;/code&gt; だけでなく、&lt;code&gt;resolve()&lt;/code&gt; も定義されている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def resolve(path, urlconf=None):
    return get_resolver(urlconf).resolve(path)

def reverse(viewname, urlconf=None, args=None, kwargs=None):
    args = args or []
    kwargs = kwargs or {}
    return iri_to_uri(u&#39;/&#39; + get_resolver(urlconf).reverse(viewname, *args, **kwargs))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数名や引数から &lt;code&gt;reverse()&lt;/code&gt; が URL の逆マッピング（名前、引数から URL を探索）を行うのにたいし、&lt;code&gt;resolve()&lt;/code&gt; が URL のマッピング（URL から探索）を担当していることは容易に想像がつく。&lt;/p&gt;

&lt;p&gt;では、&lt;code&gt;resolve()&lt;/code&gt; が返すものはなんだろうか？　これはソースコードのコメントに書いてある。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This module converts requested URLs to callback view functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RegexURLResolver is the main class here. Its resolve() method takes a URL (as
a string) and returns a tuple in this format:&lt;/p&gt;

&lt;p&gt;(view_function, function_args, function_kwargs)&lt;/p&gt;

&lt;p&gt;アクセスされた URL パス文字列を渡すと、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;View 関数&lt;/li&gt;
&lt;li&gt;引数&lt;/li&gt;
&lt;li&gt;キーワード引数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;がタプルで返ってくるらしい。&lt;/p&gt;

&lt;h3 id=&#34;regexurlresolver&#34;&gt;RegexURLResolver&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;reverse()&lt;/code&gt; も &lt;code&gt;resolve()&lt;/code&gt; も、実際の処理は &lt;code&gt;get_resolver()&lt;/code&gt; で返ってくるオブジェクトに丸投げしている。そして、先のコメントが示唆するように、&lt;code&gt;get_resolver()&lt;/code&gt; で返されるオブジェクトは &lt;code&gt;RegexURLResolver&lt;/code&gt; のインスタンスになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def get_resolver(urlconf):
...
    return RegexURLResolver(r&#39;^/&#39;, urlconf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RegexURLResolver&lt;/code&gt; は &lt;code&gt;urls.py&lt;/code&gt; に対応したクラスであり、そこで定義された &lt;code&gt;urlpatterns&lt;/code&gt; や &lt;code&gt;handler404&lt;/code&gt; などを参照している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class RegexURLResolver(object):
...
    def _get_urlconf_module(self):
        try:
            return self._urlconf_module
        except AttributeError:
            try:
                self._urlconf_module = __import__(self.urlconf_name, {}, {}, [&#39;&#39;])
...
    def _get_url_patterns(self):
        return self.urlconf_module.urlpatterns
...
    def _resolve_special(self, view_type):
        callback = getattr(self.urlconf_module, &#39;handler%s&#39; % view_type)
...
    def resolve404(self):
        return self._resolve_special(&#39;404&#39;)

    def resolve500(self):
        return self._resolve_special(&#39;500&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、&lt;code&gt;urlpatterns&lt;/code&gt; の中身は何かといえば、同じファイルで定義されている &lt;code&gt;RegexURLPattern&lt;/code&gt; インスタンスのリストだ（ただし、別の &lt;code&gt;urls.py&lt;/code&gt; を &lt;code&gt;include()&lt;/code&gt; している場合は &lt;code&gt;RegexURLPattern&lt;/code&gt; ではなく &lt;code&gt;RegexURLResolver&lt;/code&gt; インスタンスがリストに挿入されて入れ子構造になる）。このへんは patterns() や url() が定義されている &lt;code&gt;django/conf/defaults.py&lt;/code&gt; を読むと分かる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;resolve()&lt;/code&gt; メソッドの実装を見れば、URL パス文字列の対応を &lt;code&gt;urlpatterns&lt;/code&gt; から探索する様子が分かるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def resolve(self, path):
    tried = []
    match = self.regex.search(path)
    if match:
        new_path = path[match.end():]
        for pattern in self.urlconf_module.urlpatterns:
            try:
                sub_match = pattern.resolve(new_path)
            except Resolver404, e:
                tried.extend([(pattern.regex.pattern + &#39;   &#39; + t) for t in e.args[0][&#39;tried&#39;]])
            else:
                if sub_match:
                    sub_match_dict = dict([(smart_str(k), v) for k, v in match.groupdict().items()])
                    sub_match_dict.update(self.default_kwargs)
                    for k, v in sub_match[2].iteritems():
                        sub_match_dict[smart_str(k)] = v
                    return sub_match[0], sub_match[1], sub_match_dict
                tried.append(pattern.regex.pattern)
        raise Resolver404, {&#39;tried&#39;: tried, &#39;path&#39;: new_path}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;resolve()&lt;/code&gt; メソッドは &lt;code&gt;RegexURLPattern&lt;/code&gt; にも &lt;code&gt;RegexURLResolver&lt;/code&gt; にも実装されていることに注意。&lt;/p&gt;

&lt;h3 id=&#34;matchchecker&#34;&gt;MatchChecker&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;urlresolver.py&lt;/code&gt; にはこの他に &lt;code&gt;MatchChecker&lt;/code&gt; というクラスが定義されており、これは &lt;code&gt;reverse()&lt;/code&gt; の過程で正規表現をパス文字列に変換するために使われているようだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def reverse_helper(regex, *args, **kwargs):
...
    # TODO: Handle nested parenthesis in the following regex.
    result = re.sub(r&#39;\(([^)]+)\)&#39;, MatchChecker(args, kwargs), regex.pattern)
    return result.replace(&#39;^&#39;, &#39;&#39;).replace(&#39;$&#39;, &#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;余談だが、ここでは &lt;code&gt;^&lt;/code&gt; と &lt;code&gt;$&lt;/code&gt; のメタ文字しか削除していないため、他のメタ文字はそのまま残ってしまう（もっとも、通常のマッピングをする範囲で困ることはないだろうけど）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Django と Python-Markdown 1.7 で UnicodeDecodeError</title>
      <link>http://www.metareal.org/2008/04/14/python-markdown-1-7-with-django/</link>
      <pubDate>Tue, 15 Apr 2008 08:57:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/04/14/python-markdown-1-7-with-django/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.freewisdom.org/projects/python-markdown/&#34;&gt;Python Markdown&lt;/a&gt; の最新版である 1.7 を &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; で使うと、日本語など ASCII 以外の文字で UnicodeDecodeError が発生する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MARKDOWN-CRITICAL: &amp;quot;UnicodeDecodeError: Markdown only accepts unicode or ascii  input.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すでに&lt;a href=&#34;http://code.djangoproject.com/ticket/6387&#34;&gt;チケットも登録されている&lt;/a&gt;が、とりあえず古いバージョンに戻すのがよさそう。&lt;a href=&#34;http://code.djangoproject.com/ticket/5663#comment:1&#34;&gt;1.6b はバグで同様のエラーが出る&lt;/a&gt;ようなので、1.6a にしよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% sudo easy_install markdown==1.6a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;蛇足だが、この問題を調べている途中で見つけた。&lt;a href=&#34;http://code.google.com/p/python-markdown2/&#34;&gt;python-markdown2&lt;/a&gt; という、別の Markdown ライブラリも存在するようだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Django のモデルで日本語を使うと UnicodeEncodeError が発生する</title>
      <link>http://www.metareal.org/2008/04/11/django-unicode-encode-error/</link>
      <pubDate>Sat, 12 Apr 2008 07:16:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/04/11/django-unicode-encode-error/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://diary.metareal.org/2008/01/24/meet-django-django-is-a-high-level-python-web-framework/&#34;&gt;ちょっと前&lt;/a&gt;から &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; で遊んでいる。教則本代わりの &lt;a href=&#34;http://www.djangobook.com/&#34;&gt;Django Book&lt;/a&gt; も含めて、完成度の高さに驚くことしきり。&lt;/p&gt;

&lt;p&gt;ただ、実際に管理インターフェースでモデルの詳細を表示しようとすると、&lt;strong&gt;UnicodeEncodeError&lt;/strong&gt; とかいう嫌らしいエラーが出て、萎える。&lt;/p&gt;

&lt;p&gt;しかたなく &lt;code&gt;python UnicodeEncodeError django&lt;/code&gt; で検索したら &lt;a href=&#34;http://d.hatena.ne.jp/SumiTomohiko/20070120/1169300624&#34;&gt;sitecustomize.py でデフォルトのエンコーディングを変更する&lt;/a&gt;とか、いや、str 関数に渡したい場合はそりゃそうなんだろうけど、せっかくフレームワーク使ってるんだし、この解決法じゃないんだろうな、っていうのしか見つけられなくてますます萎えてたわけだけど、やっと納得できる解決法が見つかったので残しておく。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;#id1&#34;&gt;``&lt;/a&gt;svn trunk`` な Django を使っている。&lt;/p&gt;

&lt;p&gt;System Message: WARNING/2 (&lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, line 7); &lt;em&gt;backlink&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Inline literal start-string without end-string.&lt;/p&gt;

&lt;h3 id=&#34;モデルには-str-ではなく-unicode-を実装する&#34;&gt;モデルには &lt;strong&gt;str&lt;/strong&gt; ではなく &lt;strong&gt;unicode&lt;/strong&gt; を実装する&lt;/h3&gt;

&lt;p&gt;Django オンラインドキュメント和訳の &lt;a href=&#34;http://michilu.com/django/doc-ja/unicode/#str-unicode&#34;&gt;&lt;strong&gt;str&lt;/strong&gt;() と &lt;strong&gt;unicode&lt;/strong&gt;() のどちらを使うべきか&lt;/a&gt;に、そのものズバリの回答があった。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;モデルに &lt;strong&gt;str&lt;/strong&gt;() メソッドを定義する代わりに &lt;strong&gt;unicode&lt;/strong&gt;() メソッドを実装するよう推奨します． &lt;strong&gt;unicode&lt;/strong&gt;() メソッ ドの中では，モデルのフィールド値を使って好きな値を作成でき，その値がバイト 文字列として適切に表現されるかを気にせず返してかまいません&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本当だ。モデルに書いていた &lt;strong&gt;str&lt;/strong&gt; メソッドを &lt;strong&gt;unicode&lt;/strong&gt; に変えるだけで解決しちゃったよ。&lt;/p&gt;

&lt;h3 id=&#34;force-unicode&#34;&gt;force_unicode&lt;/h3&gt;

&lt;p&gt;エラーのスタックトレースを辿って、Django の &lt;code&gt;django/utils/encodings.py&lt;/code&gt; を見てみると、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def force_unicode(s, encoding=&#39;utf-8&#39;, strings_only=False, errors=&#39;strict&#39;):
...
        if not isinstance(s, basestring,):
            if hasattr(s, &#39;__unicode__&#39;):
                s = unicode(s)
            else:
                s = unicode(str(s), encoding, errors)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーは最後の str 関数の呼び出しで起きているわけだが、その前に hasattr で &lt;strong&gt;unicode&lt;/strong&gt; を調べているのが分かると思う。実をいうと上のドキュメントは、ここから &lt;strong&gt;unicode&lt;/strong&gt; を検索してみて見つけたものだった。&lt;/p&gt;

&lt;p&gt;しかし、改めて検索してみると常識っぽいな&amp;hellip;。最初の検索の仕方がまずかったか。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mac の Python をビルドするときに GNU Readline ライブラリを有効にする</title>
      <link>http://www.metareal.org/2008/04/11/building-readline-enabled-python-on-mac/</link>
      <pubDate>Fri, 11 Apr 2008 10:05:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/04/11/building-readline-enabled-python-on-mac/</guid>
      <description>

&lt;p&gt;Mac OS X では &lt;a href=&#34;http://tiswww.case.edu/php/chet/readline/rltop.html&#34;&gt;GNU の Readline ライブラリ&lt;/a&gt;がインストールには含まれておらず、Readline 互換の &lt;a href=&#34;http://sourceforge.net/projects/libedit/&#34;&gt;Libedit&lt;/a&gt; というライブラリへのシンボリックリンクとなっている（こうなっている理由はライセンス上の問題からだと思われる。GNU の Readline ライブラリは GPL で、Libedit は BSD ライセンスだ）。&lt;/p&gt;

&lt;p&gt;しかし、これが原因で Readline 対応のプログラムがコンパイルできない、コンパイルできてもヒストリ機能などが使えない、といった問題がしばしば起こる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.python.org/&#34;&gt;Python&lt;/a&gt; は後者の例で、&lt;code&gt;configure&lt;/code&gt; スクリプトはちゃんと readline ライブラリを認識し &lt;code&gt;make&lt;/code&gt; も問題なく通るのだが、実際には Readline ライブラリが無効になったバイナリがインストールされてしまう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% ./configure
...
checking for readline in -lreadline... yes
checking for rl_callback_handler_install in -lreadline... yes
checking for rl_pre_input_hook in -lreadline... yes
checking for rl_completion_matches in -lreadline... no
...
% make
...
% find . -name readline.so
# readline.so が出来ていない
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ヒストリ機能やキャレット移動のショートカットが使えないのは、やはり不便だ。これはなんとかしたい。&lt;/p&gt;

&lt;h3 id=&#34;macports-で-gnu-readline-ライブラリをインストール&#34;&gt;MacPorts で GNU Readline ライブラリをインストール&lt;/h3&gt;

&lt;p&gt;まずは &lt;a href=&#34;http://tiswww.case.edu/php/chet/readline/rltop.html&#34;&gt;GNU Readline&lt;/a&gt; ライブラリをインストールしよう。&lt;a href=&#34;http://www.macports.org/&#34;&gt;MacPorts&lt;/a&gt; を利用するのが簡単だろう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% sudo port install readline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/opt/local/lib&lt;/code&gt; 以下にインストールされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% l /opt/local/lib/libreadline.*
-r-xr-xr-x   2 root  admin  448300 Nov 13  2006 /opt/local/lib/libreadline.5.1.dylib
lrwxr-xr-x   1 root  admin      21 Nov 13  2006 /opt/local/lib/libreadline.5.dylib -&amp;gt; libreadline.5.1.dylib
-rw-r--r--   2 root  admin  574188 Nov 13  2006 /opt/local/lib/libreadline.a
lrwxr-xr-x   1 root  admin      21 Nov 13  2006 /opt/local/lib/libreadline.dylib -&amp;gt; libreadline.5.1.dylib
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;gnu-readline-ライブラリの場所を指定して-python-をビルド&#34;&gt;GNU Readline ライブラリの場所を指定して Python をビルド&lt;/h3&gt;

&lt;p&gt;あとは新しくインストールされたライブラリの場所を指定して、Python をビルドしなおすだけだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% CPPFLAGS=-I/opt/local/include LDFLAGS=-L/opt/local/lib ./configure
% make
% find . -name readline.so
./build/lib.macosx-10.3-i386-2.5/readline.so
% sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしてビルドした Python のインタプリタでは、ヒストリ機能やキャレット移動のショートカットが有効になっている。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apple によるロケール周りの変更点を Python 2.5.2 にも適用する</title>
      <link>http://www.metareal.org/2008/04/02/fixup-python-locale-problems-by-apple-darwin-patch-for-2-5-2/</link>
      <pubDate>Wed, 02 Apr 2008 10:23:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/04/02/fixup-python-locale-problems-by-apple-darwin-patch-for-2-5-2/</guid>
      <description>&lt;p&gt;最近 &lt;a href=&#34;http://www.python.org/&#34;&gt;Python&lt;/a&gt; を 2.5.2 にアップデートして同じ作業を繰り返したことと、&lt;a href=&#34;http://www.metareal.org/2007/09/09/fixup-python-locale-problems-by-apple-darwin-patch/&#34;&gt;Apple によるロケール周りの変更点を Python 2.5.1 にも適用する&lt;/a&gt;のときはパッチの適用方法について言及がなかったこともあり、そのへんも含めて手順をまとめておく。&lt;/p&gt;

&lt;p&gt;まずは Python 2.5.2 をダウンロードし展開。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
% curl -LO http://www.python.org/ftp/python/2.5.2/Python-2.5.2.tar.bz2
% tar xjf Python-2.5.2.tar.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.metareal.org/2007/09/09/fixup-python-locale-problems-by-apple-darwin-patch/&#34;&gt;Apple によるロケール周りの変更点を Python 2.5.1 にも適用する&lt;/a&gt;で公開したパッチをあてる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
% curl -LO http://www.metareal.org/wp-content/uploads/2007/09/python251_apple_locale.txt
% cd Python-2.5.2
% patch -p2 -d . &amp;lt; ../python251_apple_locale.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の &lt;code&gt;patch&lt;/code&gt; コマンドによりパッチを適用している。&lt;code&gt;-p2&lt;/code&gt; オプションの指定をしないとパッチがうまく適用されないので注意。あとは通常どおり confgure, make すればいい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
% ./configure
% make
% sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.5.3 がリリースされたら、また同じパターンで記事が一本できるな。&lt;/p&gt;

&lt;p&gt;【追記】こうしてインストールされた Python インタプリタではヒストリ機能などが有効になっていないかもしれない。その場合は &lt;a href=&#34;http://www.metareal.org/2008/04/11/building-readline-enabled-python-on-mac/&#34;&gt;Mac の Python をビルドするときに GNU Readline ライブラリを有効にする&lt;/a&gt;をどうぞ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apple によるロケール周りの変更点を Python 2.5.1 にも適用する</title>
      <link>http://www.metareal.org/2007/09/09/fixup-python-locale-problems-by-apple-darwin-patch/</link>
      <pubDate>Sun, 09 Sep 2007 11:49:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/09/09/fixup-python-locale-problems-by-apple-darwin-patch/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.metareal.org/2007/07/19/problem-with-python-getpreferredencoding-in-trac-mac-os-x/&#34;&gt;Python: Mac OS X での locale.getpreferredencoding()&lt;/a&gt; では、Mac OS X に Python 2.5.1 をソースコードからインストールした場合に発生する、ロケール周りの問題点について書いた。&lt;/p&gt;

&lt;p&gt;要約すると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;locale.getpreferredencoding()&lt;/code&gt; の返すエンコーディングが &lt;code&gt;X-MAC-JAPANESE&lt;/code&gt; になってしまう&lt;/li&gt;
&lt;li&gt;Python では &lt;code&gt;X-MAC-JAPANESE&lt;/code&gt; がデフォルトではサポートされていないため、&lt;code&gt;locale.getpreferredencoding()&lt;/code&gt; を利用したエンコード、デコードができない&lt;/li&gt;
&lt;li&gt;_localmodule.c を変更して、&lt;code&gt;X-MAC-JAPANESE&lt;/code&gt; の代わりに &lt;code&gt;shift_jis&lt;/code&gt; を返すようにして解決&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という内容だった。&lt;/p&gt;

&lt;p&gt;しかし、しばらくして「っき」さんより&lt;a href=&#34;http://www.metareal.org/2007/07/19/problem-with-python-getpreferredencoding-in-trac-mac-os-x/#comment-4027&#34;&gt;コメントをいただいた&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;上記のlocale.getpreferredencoding()の返り値ですが、10.4.9に含まれているOS標準のPython 2.3.5では、デフォルトがUS-ASCIIになっていて、LANG環境変数も見てくれます。&lt;/p&gt;

&lt;p&gt;これは、Appleがパッケージングの際に、&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.opensource.apple.com/darwinsource/10.4.9.x86/python-16.1.3/&#34;&gt;http://www.opensource.apple.com/darwinsource/10.4.9.x86/python-16.1.3/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以下に含まれているパッチを適用して、ロケール周りのdefined(APPLE)や ‘darwin’ を無効にしているからです。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;たしかに、前回の記事では Mac OS X に標準でバンドルされている Python にまで考えが及んでいなかった。「っき」さんの指摘通り、互換性のことも考慮すると、Apple のパッケージングを見習うのがよさそうだ。&lt;/p&gt;

&lt;p&gt;というわけで、Apple のパッチを適用した Python 2.5.1 の&lt;a href=&#34;http://snipplr.com/view/6028/apples-modifications-to-python-251-localepy-/&#34;&gt;パッチファイルをアップしておく&lt;/a&gt;。以降は、このパッチファイルを作成するまでの詳細である。&lt;/p&gt;

&lt;h3 id=&#34;mac-os-x-に標準でパッケージングされている-python&#34;&gt;Mac OS X に標準でパッケージングされている Python&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://developer.apple.com/&#34;&gt;Apple Developer Connection&lt;/a&gt; の &lt;a href=&#34;http://developer.apple.com/opensource/index.html&#34;&gt;Open Source&lt;/a&gt; ページでは Mac OS X のベースとなっている Darwin のソースコードが公開されている。&lt;a href=&#34;http://www.opensource.apple.com/darwinsource/10.4.9.x86/&#34;&gt;現時点での最新版は Mac OS X 10.4.9 のもの&lt;/a&gt;なので、今回のパッチはこれを基にした。&lt;/p&gt;

&lt;p&gt;上記ページからダウンロードできる &lt;a href=&#34;http://www.opensource.apple.com/darwinsource/tarballs/other/python-16.1.3.tar.gz&#34;&gt;python-16.1.3.tar.gz&lt;/a&gt; には Mac OS X にバンドルされている Python に適用されたパッチが含まれているので、このうち、ロケール周りに関係あるものを Python 2.5.1 のソースコードに適用すればよさそうだ。&lt;/p&gt;

&lt;h3 id=&#34;apple-のパッチを-python-2-5-1-に適用する&#34;&gt;Apple のパッチを Python 2.5.1 に適用する&lt;/h3&gt;

&lt;p&gt;まずは、Python 2.5.1 のソースコードと Apple のパッチ (python-16.1.3.tar.gz) を同じディレクトリにダウンロードして展開する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% curl -LO http://www.python.org/ftp/python/2.5.1/Python-2.5.1.tgz
% curl -LO http://www.opensource.apple.com/darwinsource/tarballs/other/python-16.1.3.tar.gz
% tar xvzf Python-2.5.1.tgz
% tar xvzf python-16.1.3.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のようなシェルスクリプトでパッチを適用した。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PROJECT=Python-2.5.1
FIX=python-16.1.3/fix
echo ed - ${PROJECT}/Lib/locale.py \&amp;lt; ${FIX}/locale.py.ed &amp;amp;&amp;amp; \
ed - ${PROJECT}/Lib/locale.py &amp;lt; ${FIX}/locale.py.ed &amp;amp;&amp;amp; \
echo ed - ${PROJECT}/Modules/_localemodule.c \&amp;lt; ${FIX}/_localemodule.c.ed &amp;amp;&amp;amp; \
ed - ${PROJECT}/Modules/_localemodule.c &amp;lt; ${FIX}/_localemodule.c.ed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要するに、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;python-16.1.3/fix/locale.py.ed&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;python-16.1.3/fix/_localemodule.c.ed&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というふたつのパッチファイルを適用したわけだ。&lt;/p&gt;

&lt;p&gt;その diff をとったものが&lt;a href=&#34;http://snipplr.com/view/6028/apples-modifications-to-python-251-localepy-/&#34;&gt;上記のパッチファイル&lt;/a&gt;となる。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python: Mac OS X での locale.getpreferredencoding() </title>
      <link>http://www.metareal.org/2007/07/19/problem-with-python-getpreferredencoding-in-trac-mac-os-x/</link>
      <pubDate>Thu, 19 Jul 2007 10:30:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/07/19/problem-with-python-getpreferredencoding-in-trac-mac-os-x/</guid>
      <description>

&lt;p&gt;（追記）この記事に載せているパッチよりも &lt;a href=&#34;http://weblog.metareal.org/2007/09/09/fixup-python-locale-problems-by-apple-darwin-patch/&#34;&gt;Apple によるロケール周りの変更点を Python 2.5.1 にも適用する&lt;/a&gt;のパッチを使った方がよさそうです。Mac OS X 標準の Python との互換性があります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://trac.edgewall.org/wiki/TracInstall&#34;&gt;TracInstall&lt;/a&gt; に従って、Mac OS X で &lt;a href=&#34;http://trac.edgewall.org/&#34;&gt;Trac&lt;/a&gt; を動かそうとしている。&lt;a href=&#34;http://weblog.metareal.org/category/subversion/&#34;&gt;以前試したときは頓挫した&lt;/a&gt;のだが、今回は Python を含む&lt;strong&gt;すべてのライブラリ&lt;/strong&gt;を一からインストールして、じっくりやってみることにした。&lt;/p&gt;

&lt;p&gt;とりあえず、&lt;code&gt;tracd&lt;/code&gt; を起動するところまでは問題なくいったのだけれど、URL にアクセスしてみると早速こんなエラーが。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Traceback (most recent call last):
  File &amp;quot;/path/to/trac/lib/python2.5/site-packages/trac/web/main.py&amp;quot;, line 406, in dispatch_request
    dispatcher.dispatch(req)
  File &amp;quot;/path/to/trac/lib/python2.5/site-packages/trac/web/main.py&amp;quot;, line 207, in dispatch
    populate_hdf(req.hdf, self.env, req)
  File &amp;quot;/path/to/trac/lib/python2.5/site-packages/trac/web/main.py&amp;quot;, line 77, in populate_hdf
    &#39;time&#39;: format_datetime(),
  File &amp;quot;/path/to/trac/lib/python2.5/site-packages/trac/util/datefmt.py&amp;quot;, line 65, in format_datetime
    return unicode(text, encoding, &#39;replace&#39;)
LookupError: unknown encoding: X-MAC-JAPANESE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じっくりやってみる、と書いた矢先にくじけそうになりましたが、諦めずに原因を追ってみますね。&lt;/p&gt;

&lt;p&gt;その前に、今回試したバージョンは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python 2.5.1&lt;/li&gt;
&lt;li&gt;Trac 0.10.4&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;h3 id=&#34;ソースコードを読む&#34;&gt;ソースコードを読む&lt;/h3&gt;

&lt;p&gt;スタックトレースから例外の発生箇所は簡単に分かるので、ソースコードを読んでみる (&lt;code&gt;/trac/util/datefmt.py&lt;/code&gt;) 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def format_datetime(t=None, format=&#39;%x %X&#39;, gmt=False):
    if t is None:
        t = time.time()
    if not isinstance(t, (list, tuple, time.struct_time)):
        if gmt:
            t = time.gmtime(float(t))
        else:
            t = time.localtime(float(t))

    text = time.strftime(format, t)
    encoding = locale.getpreferredencoding() or sys.getdefaultencoding()
    if sys.platform != &#39;win32&#39;:
        encoding = locale.getlocale(locale.LC_TIME)[1] or encoding
        # the above is broken on win32, e.g. we&#39;d get &#39;437&#39; instead of &#39;cp437&#39;
    return unicode(text, encoding, &#39;replace&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回のエラーはビルトイン関数の &lt;code&gt;unicode&lt;/code&gt; が &lt;code&gt;X-MAC-JAPANESE&lt;/code&gt; エンコーディングをサポートしていないのが原因のようだ。&lt;code&gt;X-MAC-JAPANESE&lt;/code&gt; は Mac ユーザにとってはお馴染みの MacJapanese（ほぼ Shift-JIS）のことだろう。たしかにリファレンスの &lt;a href=&#34;http://docs.python.org/lib/standard-encodings.html&#34;&gt;4.8.3 Standard Encodings&lt;/a&gt; を読んでもそれらしきエンコーディングがない。&lt;/p&gt;

&lt;p&gt;となると、考えられる解決方法はふたつ&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MacJapanese をサポートするコーデックを追加&lt;/li&gt;
&lt;li&gt;そもそも、&lt;code&gt;locale.getpreferredencoding()&lt;/code&gt; でサポートしていないエンコーディングを返さない。この場合は &lt;code&gt;shift_jis&lt;/code&gt; を返してしまっていい気がする&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;まあ、1. が真っ当なんだろうけど、2. でも問題ないというか、むしろ、&lt;code&gt;getpreferredencoding&lt;/code&gt; という名前のメソッドがサポートされていないエンコーディングを返すよりいいんじゃないだろうか。&lt;/p&gt;

&lt;h3 id=&#34;localmodule-c-を変更&#34;&gt;_localmodule.c を変更&lt;/h3&gt;

&lt;p&gt;とりあえず、Python 2.5.1 の &lt;code&gt;Modules/_localemodule.c&lt;/code&gt; で、&lt;code&gt;X-MAC-JAPANESE&lt;/code&gt; の場合は &lt;code&gt;shift_jis&lt;/code&gt; を返すように変更してみた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--- Modules/_localemodule.c.orig        2007-07-19 02:47:21.000000000 +0900
+++ Modules/_localemodule.c     2007-07-19 03:17:28.000000000 +0900
@@ -426,6 +426,7 @@
     case kCFStringEncodingMacCyrillic: return &amp;quot;mac-cyrillic&amp;quot;;
     case kCFStringEncodingMacTurkish: return &amp;quot;mac-turkish&amp;quot;;
     case kCFStringEncodingMacIcelandic: return &amp;quot;mac-icelandic&amp;quot;;
+    case kCFStringEncodingMacJapanese: return &amp;quot;shift_jis&amp;quot;;
     /* XXX which one is mac-latin2? */
     }
     if (!name) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、このへんのコードでは Mac OS X のフレームワークである &lt;a href=&#34;http://developer.apple.com/corefoundation/&#34;&gt;Core Foundation&lt;/a&gt; が利用されている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://devworld.apple.com/documentation/CoreFoundation/Reference/CFStringRef/Reference/reference.html&#34;&gt;CFString Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://homepage.mac.com/mkino2/core/index.html&#34;&gt;CoreFoundation の秘密&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Mac OS X では MoinMoin が UnboundLocalError で動かない</title>
      <link>http://www.metareal.org/2007/04/08/moinmoin-on-macosx-failed-unboundlocalerror/</link>
      <pubDate>Mon, 09 Apr 2007 02:52:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/04/08/moinmoin-on-macosx-failed-unboundlocalerror/</guid>
      <description>&lt;p&gt;作業メモや備忘録を残しておくためのシステムがほしくて、&lt;a href=&#34;http://moinmoin.wikiwikiweb.de/&#34;&gt;MoinMoin&lt;/a&gt; を自宅サーバの Mac OS X にインストールした。&lt;/p&gt;

&lt;p&gt;ブログだとやっぱり時系列で流れちゃうし、書き殴りのメモとかは公開しづらいしね。MoinMoin はページごとのパーミッションを制御できるなど、今回の用途にはぴったり。&lt;/p&gt;

&lt;p&gt;ただし、バージョン 1.5.7 はそのままだと Mac OS X では動かなかった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UnboundLocalError: local variable &#39;File&#39; referenced before assignment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなエラーが出てしまう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.sagemath.org:9002/sage_trac/ticket/104&#34;&gt;ここに書かれている通り&lt;/a&gt;、&lt;code&gt;util/filesys.py&lt;/code&gt; を修正すると動くようになった。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>