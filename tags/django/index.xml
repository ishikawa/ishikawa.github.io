<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>METAREAL</title>
    <link>http://www.metareal.org/tags/django/index.xml</link>
    <description>Recent content on METAREAL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <copyright>copyright © 2006-Present Takanori Ishikawa.</copyright>
    <atom:link href="http://www.metareal.org/tags/django/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Google AppEngine で Django 1.1 を使う</title>
      <link>http://www.metareal.org/2009/12/02/running-django-1-1-on-google-appengine/</link>
      <pubDate>Thu, 03 Dec 2009 12:42:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2009/12/02/running-django-1-1-on-google-appengine/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://code.google.com/appengine/&#34;&gt;Google AppEngine&lt;/a&gt; の SDK および実行環境には、Web アプリケーション・フレームワークの &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; がプリインストールされている。&lt;/p&gt;

&lt;p&gt;しかし、デフォルトで有効になっているのは 0.96 という相当古いバージョンだ（もっとも、Google AppEngine リリース時点では、これが最新のバージョンであった）。すでにサポートも終了しており、バグや脆弱性の修正もされないため、できれば最新の 1.0/1.1系列を使いたい、という人が大半だろう。&lt;/p&gt;

&lt;p&gt;しかし、これまで、バージョン 1.0 以降の Django を Google AppEngine で使うのは骨の折れる作業だった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使いたいバージョンの Django を丸ごとアップロードしなくてはいけなかった&lt;/li&gt;
&lt;li&gt;Django はファイル数が多いため、アップロード可能なファイル数制限を超えやすい&lt;/li&gt;
&lt;li&gt;デフォルトで有効になる古いバージョンの Django を無効化するために、&lt;a href=&#34;http://code.google.com/intl/en/appengine/articles/django.html&#34;&gt;呪文めいたコードが必要&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;だが、いまや状況は変わった。SDK &lt;a href=&#34;http://code.google.com/p/googleappengine/wiki/SdkReleaseNotes#Version_1.2.3_-_June_18,_2009&#34;&gt;1.2.3 からは Django 1.0&lt;/a&gt; が、SDK &lt;a href=&#34;http://code.google.com/p/googleappengine/wiki/SdkReleaseNotes#Version_1.2.5_-_September_3,_2009&#34;&gt;1.2.5 からは Django 1.1&lt;/a&gt; がサポートされ、Google AppEngine でも、簡単に Django 1.x を動かせるようになった。&lt;/p&gt;

&lt;h3 id=&#34;google-appengine-dist-use-library&#34;&gt;google.appengine.dist.use_library&lt;/h3&gt;

&lt;p&gt;SDK 1.2.&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;.2.5 からは &lt;a href=&#34;http://code.google.com/p/googleappengine/source/browse/#svn/trunk/python/google/appengine/dist&#34;&gt;google.appengine.dist&lt;/a&gt; モジュールの &lt;code&gt;use_library&lt;/code&gt; 関数を使うことで Django 1.0/1.1 を選択できるようになった。&lt;/p&gt;

&lt;p&gt;使い方は簡単で、&lt;code&gt;main.py&lt;/code&gt; に以下のような記述を追加するだけだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import os
os.environ[&#39;DJANGO_SETTINGS_MODULE&#39;] = &#39;settings&#39;

from google.appengine.dist import use_library
use_library(&#39;django&#39;, &#39;1.1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これまで開発者が各自行っていた &lt;code&gt;sys.path&lt;/code&gt; の調整は &lt;code&gt;use_library&lt;/code&gt; 関数がやってくれる。&lt;/p&gt;

&lt;p&gt;更に嬉しいことに、Django のコードをアップロードする必要もなくなった。Google AppEngine のサーバには Django 1.0/1.1 がインストールされている。ただし、SDK には Django 0.96 しか添付されていないので、1.0/1.1 を使う場合は、あらかじめローカルのマシンに Django 1.0/1.1 をインストールしておこう。&lt;/p&gt;

&lt;h3 id=&#34;django-のバージョンと-dos-攻撃可能な脆弱性について&#34;&gt;Django のバージョンと DoS 攻撃可能な脆弱性について&lt;/h3&gt;

&lt;p&gt;なお、実際に有効になる Django の詳細なバージョンは、本記事執筆時点の 2009 年 11 月で以下のようになっている（&lt;code&gt;django.VERSION&lt;/code&gt; で調べた）。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;use_library&lt;/th&gt;
&lt;th&gt;Django version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;(None)&lt;/td&gt;
&lt;td&gt;0.96.4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;use_library(1.0)&lt;/td&gt;
&lt;td&gt;1.0.2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;use_library(1.1)&lt;/td&gt;
&lt;td&gt;1.1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;del&gt;残念ながら、1.0/1.1 は &lt;a href=&#34;http://www.djangoproject.com/weblog/2009/oct/09/security/&#34;&gt;DoS 攻撃可能な脆弱性が修正されたバージョン&lt;/a&gt; ではないようだ（修正バージョンは 1.0.&lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;.1.1）。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;この脆弱性は &lt;code&gt;EmailField&lt;/code&gt; か &lt;code&gt;URLField&lt;/code&gt; に関連したものなので、それらを使っているプログラムでは Google AppEngine にインストールされた Django のアップデートを待つか、これまでどおりの方法で、修正済みのバージョンをアップロードした方が安全だろう。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Google AppEngine プロジェクトに&lt;a href=&#34;http://code.google.com/p/googleappengine/issues/detail?id=2447&#34;&gt;報告&lt;/a&gt;したところ、GAE で有効になるバージョンは修正済みのものである、とのこと。失礼しました。&lt;/p&gt;

&lt;h3 id=&#34;main-py-のサンプル&#34;&gt;main.py のサンプル&lt;/h3&gt;

&lt;p&gt;実際に &lt;code&gt;use_library&lt;/code&gt; を使ったサンプルを &lt;a href=&#34;http://gist.github.com/245523&#34;&gt;gist:245523&lt;/a&gt; で公開している。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google App Engine で Django 1.0 を動かす</title>
      <link>http://www.metareal.org/2008/10/02/running-django-1-0-on-google-app-engine/</link>
      <pubDate>Thu, 02 Oct 2008 10:26:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/10/02/running-django-1-0-on-google-app-engine/</guid>
      <description>

&lt;p&gt;このブログは &lt;a href=&#34;http://www.metareal.org/2008/05/20/porting-weblog-to-google-app-engine/&#34;&gt;Google App Engine と Django で動かしている&lt;/a&gt;のだが、いままで &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; はすこし古い開発版を使っていた。&lt;/p&gt;

&lt;p&gt;しかし、先頃めでたく &lt;a href=&#34;http://www.djangoproject.com/weblog/2008/sep/03/1/&#34;&gt;Django 1.0 もリリースされた&lt;/a&gt;ことだし、このブログも最新の開発版にアップデートすることにした。とりあえず、すこしソースコードを修正するだけで、動くだけは動いたので、変更点を残しておく。もっとも、このブログは機能がすくない分、Django に依存している箇所もすくないので、他のプログラムではこれ以上の修正が必要かもしれない。&lt;/p&gt;

&lt;p&gt;また、Django を Google App Engine 上で動かす方法については、もともと、&lt;a href=&#34;http://code.google.com/appengine/articles/django.html&#34;&gt;Running Django on Google App Engine&lt;/a&gt; を参考にしている。そのため、他の手段、たとえば &lt;a href=&#34;http://code.google.com/p/google-app-engine-django/&#34;&gt;Google App Engine Helper for Django&lt;/a&gt; を使っている人にとっては、この記事は役に立たないだろう。&lt;/p&gt;

&lt;h3 id=&#34;django-dispatch-dispatcher-connect&#34;&gt;django.dispatch.dispatcher.connect&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;django.dispatch.dispatcher.connect&lt;/code&gt;, &lt;code&gt;django.dispatch.dispatcher.disconnect&lt;/code&gt; は使えなくなっていた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- ../metareal.django.0.9/main.py    2008-06-06 17:33:42.000000000 +0900
+++ ./main.py 2008-10-02 21:14:00.000000000 +0900
@@ -53,20 +53,17 @@

 import django.core.handlers.wsgi
 import django.core.signals
-import django.db
-import django.dispatch.dispatcher
+from django.db import _rollback_on_exception
+from django.core import signals

 def log_exception(*args, **kwds):
     logging.exception(&#39;Exception in request:&#39;)

 # Log errors.
-django.dispatch.dispatcher.connect(
-    log_exception, django.core.signals.got_request_exception)
+signals.got_request_exception.connect(log_exception)

 # Unregister the rollback event handler.
-django.dispatch.dispatcher.disconnect(
-    django.db._rollback_on_exception,
-    django.core.signals.got_request_exception)
+signals.got_request_exception.disconnect(_rollback_on_exception)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;newforms&#34;&gt;newforms&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;django.newforms&lt;/code&gt; を &lt;code&gt;django.forms&lt;/code&gt; に置き換える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- ../metareal.django.0.9/weblog/forms.py    2008-05-16 15:08:47.000000000 +0900
+++ ./weblog/forms.py 2008-10-02 21:15:45.000000000 +0900
@@ -1,4 +1,4 @@
-from django import newforms as forms
+from django import forms
 from django.utils.translation import ugettext_lazy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用している &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; および &lt;a href=&#34;http://code.google.com/p/googleappengine/wiki/SdkReleaseNotes&#34;&gt;Google App Engine SDK&lt;/a&gt; それぞれのバージョンは以下の通り。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Django 1.0 (revision 9109)&lt;/li&gt;
&lt;li&gt;Google App Engine SDK 1.1.4&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そういえば、Google App Engine は SDK 1.1.3 から zipserve という新しいモジュールが追加されたり、と徐々に機能も増えてるので、このへんも使っていきたい。&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://djangoproject.jp/doc/ja/1.0/releases/1.0-porting-guide.html&#34;&gt;アプリケーションを Django 0.96 から 1.0 に移行する — Django v1.0 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://googleappengine.blogspot.com/2008/09/sdk-113-now-available-for-download.html&#34;&gt;Google App Engine Blog: SDK 1.1.3 Now Available for download&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Django のキャッシュで Google App Engine の Memcache API を使う</title>
      <link>http://www.metareal.org/2008/05/29/django-cache-framework-meets-appengine-memcache-api/</link>
      <pubDate>Thu, 29 May 2008 01:48:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/05/29/django-cache-framework-meets-appengine-memcache-api/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://googleappengine.blogspot.com/&#34;&gt;Google App Engine ブログ&lt;/a&gt;で&lt;a href=&#34;http://googleappengine.blogspot.com/2008/05/announcing-open-signups-expected.html&#34;&gt;新しい動き&lt;/a&gt;があった。トピックは以下の通り。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;アカウント数の制限を撤廃&lt;/li&gt;
&lt;li&gt;課金の料金体系について&lt;/li&gt;
&lt;li&gt;画像操作のための API&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://code.google.com/appengine/docs/memcache/&#34;&gt;Memcache API&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;どれひとつとっても、重大な発表ばかりだ。プラットホームとしての Google App Engine に注目している方は 1. 2. が特に気になるだろうし、利用者からすれば、3. 4. は待ち焦がれていた機能だろう。&lt;/p&gt;

&lt;h3 id=&#34;重いページをキャッシュする&#34;&gt;重いページをキャッシュする&lt;/h3&gt;

&lt;p&gt;このブログを &lt;a href=&#34;http://www.metareal.org/2008/05/20/porting-weblog-to-google-app-engine/&#34;&gt;Google App Engine に移行&lt;/a&gt;して一週間が経った。しかし、Admin Console でログを確認してみると、ところどころで警告が出ている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;quot;GET /index.xml HTTP/1.1&amp;quot; 200 117413 - -
...
This request used a high amount of CPU, and was roughly 5.5 times over the average request CPU limit. High CPU requests have a small quota, and if you exceed this quota, your app will be temporarily disabled.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら、フィードの生成が重いようである。&lt;/p&gt;

&lt;p&gt;考えてみれば、フィードがリクエストされるたびに、この重い処理を繰り返す必要はない。どうせ、記事の更新があるまでは生成される内容は同じだし、記事の更新をリアルタイムに反映する必要もないだろう。キャッシュしてしまおう。&lt;/p&gt;

&lt;h3 id=&#34;the-django-cache-framework&#34;&gt;The Django cache framework&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; には&lt;a href=&#34;http://www.djangoproject.com/documentation/cache/&#34;&gt;簡単に使えるキャッシュ・フレームワーク&lt;/a&gt;（&lt;a href=&#34;http://ymasuda.jp/python/django/docs/cache.html&#34;&gt;和訳&lt;/a&gt;）が組込まれており、&lt;a href=&#34;http://danga.com/memcached/&#34;&gt;memcached&lt;/a&gt; もサポートされている。&lt;/p&gt;

&lt;p&gt;今回は &lt;strong&gt;Django のキャッシュ・フレームワークが memcached の代わりに GAE の Memcache API を使うようにする&lt;/strong&gt;ことで、コンテンツをキャッシュしてみよう。&lt;/p&gt;

&lt;p&gt;Note&lt;/p&gt;

&lt;p&gt;以下で紹介する方法は、&lt;a href=&#34;http://code.google.com/p/google-app-engine-django/&#34;&gt;Google App Engine Helper for Django&lt;/a&gt; に投稿された&lt;a href=&#34;http://code.google.com/p/google-app-engine-django/issues/detail?id=27&#34;&gt;パッチ&lt;/a&gt;に基づいている。この機能が Google App Engine Helper for Django に取り込まれる日も近いだろう。&lt;/p&gt;

&lt;p&gt;この修正は簡単で、&lt;code&gt;main.py&lt;/code&gt; に以下の行を追加するだけである。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Install App Engine memcache backend for cache framework
from google.appengine.api import memcache
sys.modules[&#39;memcache&#39;] = memcache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変更は一目瞭然。トップレベルの &lt;code&gt;memcache&lt;/code&gt; モジュールを GAE の &lt;code&gt;memcache&lt;/code&gt; モジュールにしてしまう。&lt;/p&gt;

&lt;p&gt;あとは、Django のキャッシュ・フレームワークを設定するだけだ。&lt;code&gt;settings.py&lt;/code&gt; に &lt;code&gt;CACHE_BACKEND&lt;/code&gt; の指定を追加しよう。GAE の Memcache API では接続先や負荷分散を指定する必要はないので、ホストの部分は空にしておく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CACHE_BACKEND = &#39;memcached:///&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とりあえず、フィードをキャッシュしたかったので &lt;code&gt;cache_page&lt;/code&gt; デコレータで、フィードを生成している View をキャッシュするようにした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from django.views.decorators.cache import cache_page, never_cache

@cache_page
def archive_tag(request, slug, page=1):
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たったこれだけで、初回リクエスト以降、重いフィード生成の処理をキャッシュしてくれるようになった。&lt;/p&gt;

&lt;h3 id=&#34;keyerror&#34;&gt;KeyError&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;（2008.5.29 追記）&lt;/strong&gt;memcached.Client#get が &lt;code&gt;KeyError&lt;/code&gt; を返すことがあるようだ。&lt;a href=&#34;http://code.google.com/appengine/docs/memcache/clientclass.html#Client_get&#34;&gt;キーが存在しない場合は None を返すはず&lt;/a&gt;なので、バグかもしれない。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://groups.google.com/group/google-appengine/browse_thread/thread/48eea75a4b1e54cf/b59461ba28810c86?lnk=gst&amp;amp;q=memcache#b59461ba28810c86&#34;&gt;memcache module working? - Google App Engine | Google グループ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ただ、公開直後の時点では &lt;code&gt;KeyError&lt;/code&gt; が頻発し、エラーページが表示されてしまう。以下のようなコードで、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def silent_missing_key_error(func):
    def inner(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except KeyError:
            logging.exception(&amp;quot;KeyError in google.appengine.api.memcache&amp;quot;)
            return None
    return inner

from django.core.cache.backends.memcached import CacheClass as MemcacheCache
MemcacheCache.get = silent_missing_key_error(MemcacheCache.get)
MemcacheCache.get_many = silent_missing_key_error(MemcacheCache.get_many)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;KeyError&lt;/code&gt; が起こった場合はログに残して、&lt;code&gt;None&lt;/code&gt; を返すようにしている。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XViewMiddleware の謎</title>
      <link>http://www.metareal.org/2008/05/24/django-xview-middleware-tour/</link>
      <pubDate>Sat, 24 May 2008 09:12:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/05/24/django-xview-middleware-tour/</guid>
      <description>

&lt;p&gt;疑問に思ったことはないだろうか。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; の &lt;a href=&#34;http://www.djangoproject.com/documentation/middleware/&#34;&gt;Middleware&lt;/a&gt;（&lt;a href=&#34;http://michilu.com/django/doc-ja/middleware/&#34;&gt;和訳&lt;/a&gt;）である。まずは、&lt;code&gt;settings.py&lt;/code&gt; を見てほしい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MIDDLEWARE_CLASSES = (
    &#39;django.middleware.common.CommonMiddleware&#39;,
    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,
    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,
    &#39;django.middleware.doc.XViewMiddleware&#39;,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デフォルトではこのような設定になっている。上から三つは問題ないだろう。名前からだいたいの機能は想像できるはずだし、おそらくあなたは間違っていない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MIDDLEWARE_CLASSES = (
    ...
    &#39;django.middleware.doc.XViewMiddleware&#39;,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;問題はこれだ。&lt;code&gt;XViewMiddleware&lt;/code&gt; ——名前だけでは、どんな働きをするのか見当もつかない。&lt;/p&gt;

&lt;h3 id=&#34;xviewmiddleware-を試す&#34;&gt;XViewMiddleware を試す&lt;/h3&gt;

&lt;p&gt;まずはドキュメントを読んでみようか。&lt;a href=&#34;http://www.djangoproject.com/documentation/middleware/#django-middleware-doc-xviewmiddleware&#34;&gt;XViewMiddleware のドキュメント&lt;/a&gt;（&lt;a href=&#34;http://michilu.com/django/doc-ja/middleware/#django-middleware-doc-xviewmiddleware&#34;&gt;和訳&lt;/a&gt;）によると、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Sends custom X-View HTTP headers to HEAD requests that come from IP addresses defined in the INTERNAL_IPS setting. This is used by Django’s automatic documentation system.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;INTERNAL_IPS 設定に定義されている IP アドレスから来た HEAD リクエストに 対してカスタムの X-View HTTP ヘッダを送信します。このミドルウェアは Django の自動ドキュメントシステムで使われています。&lt;/p&gt;

&lt;p&gt;まとめると、&lt;code&gt;XViewMiddleware&lt;/code&gt; は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;settings.INTERNAL_IPS&lt;/code&gt; に許可する IP アドレスを設定する&lt;/li&gt;
&lt;li&gt;その IP からの HEAD リクエストに対して、&lt;/li&gt;
&lt;li&gt;Django 独自の &lt;code&gt;X-View&lt;/code&gt; レスポンスヘッダを返す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という働きをするようだ。&lt;/p&gt;

&lt;p&gt;では、実際に試してみよう。&lt;code&gt;settings.py&lt;/code&gt; を開き、&lt;code&gt;INTERNAL_IPS&lt;/code&gt; にループバック・アドレスを追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INTERNAL_IPS = (
    &#39;127.0.0.1&#39;,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HEAD リクエストは &lt;code&gt;curl&lt;/code&gt; コマンドなどで送信することができる。&lt;a href=&#34;http://www.metareal.org/2008/05/20/porting-weblog-to-google-app-engine/&#34;&gt;このブログも Django で書かれている&lt;/a&gt;ので試してみた（ローカルの開発環境で、だが）。&lt;/p&gt;

&lt;p&gt;結果は以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% curl --head http://127.0.0.1:8000/
HTTP/1.0 200 OK
Server: Development/1.0 Python/2.5.2
Date: Sat, 24 May 2008 10:14:25 GMT
X-View: weblog.views.archive
Vary: Accept-Language
Content-Type: text/html; charset=utf-8
Content-Language: ja-jp
Cache-Control: no-cache
content-length: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;X-View: weblog.views.archive&lt;/strong&gt; という行に注目してほしい。これが &lt;code&gt;XViewMiddleware&lt;/code&gt; のすべて、 &lt;code&gt;X-View&lt;/code&gt; ヘッダである。&lt;/p&gt;

&lt;h3 id=&#34;x-view-ヘッダの利用&#34;&gt;X-View ヘッダの利用&lt;/h3&gt;

&lt;p&gt;もう一度、&lt;code&gt;X-View&lt;/code&gt; ヘッダを見てみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X-View: weblog.views.archive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;お気づきだろうか。そう。これは View のパスである。&lt;/p&gt;

&lt;p&gt;つまり、さきほどの例でいえば、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://127.0.0.1:8000/&lt;/code&gt; に HEAD リクエストを送信し、&lt;/li&gt;
&lt;li&gt;返された &lt;code&gt;X-View&lt;/code&gt; ヘッダを調べることで、&lt;/li&gt;
&lt;li&gt;このページの内容を生成している View が &lt;code&gt;weblog.views.archive&lt;/code&gt; であることが分かる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というわけだ。&lt;/p&gt;

&lt;p&gt;実際に、Django の管理インターフェースでも、&lt;code&gt;X-View&lt;/code&gt; ヘッダは利用されている。&lt;/p&gt;

&lt;p&gt;これについては、Django のリリース・マネージャーであり、&lt;a href=&#34;http://www.amazon.co.jp/gp/product/1590599969?ie=UTF8&amp;amp;tag=webloandlogic-22&amp;amp;linkCode=as2&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=1590599969&#34;&gt;Practical Django Projects&lt;/a&gt; の著者でもある James Bennett 氏のブログに詳しい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.b-list.org/weblog/2007/nov/07/bookmarklets/&#34;&gt;The B-List: Documentation bookmarklets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この記事は Django の管理インターフェースにある機能のうち、自動ドキュメンテーション機能について書かれたものだ。自動ドキュメンテーション機能については、スクリーンショットを見てもらうのがいい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.flickr.com/photos/ishikawa_takanori/2518433072/&#34;&gt;&lt;img src=&#34;http://farm3.static.flickr.com/2380/2518433072_b631bce90c_m.jpg&#34; alt=&#34;Django Admin: Automatic Documentation&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このように、View と URL の対応関係（とソースコードのドキュメント）の一覧を生成してくれる。一風変わっているのは、&lt;strong&gt;ブックマークレットが用意されている&lt;/strong&gt;ことだろう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.flickr.com/photos/ishikawa_takanori/2518433076/&#34;&gt;&lt;img src=&#34;http://farm4.static.flickr.com/3206/2518433076_00967f124f_m.jpg&#34; alt=&#34;Django Admin: Documentation Bookmarklet&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;URL との対応関係を知りたいページで、ブックマークレットをクリックすれば、該当する管理インターフェースのページにリダイレクトされる、というわけ。気が利いている。&lt;/p&gt;

&lt;p&gt;そして、このブックマークレットは表示中の URL に HEAD リクエストを送信し、&lt;code&gt;X-View&lt;/code&gt; ヘッダを見ることでリダイレクト先の URL を決定している。&lt;/p&gt;

&lt;h3 id=&#34;まとめ&#34;&gt;まとめ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XViewMiddleware&lt;/code&gt; は HEAD リクエストに対して &lt;code&gt;X-View&lt;/code&gt; レスポンスヘッダを返す&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X-View&lt;/code&gt; ヘッダの中身は、リクエストされた URL の内容を生成している View のパスである&lt;/li&gt;
&lt;li&gt;Django の管理インターフェースでも利用されている&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これでもう何も怖いものはない。この機能を活用するもよし、デバッグ目的だと割り切るなら無効にするもよし。それは自由だ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google App Engine への移行</title>
      <link>http://www.metareal.org/2008/05/20/porting-weblog-to-google-app-engine/</link>
      <pubDate>Tue, 20 May 2008 07:39:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/05/20/porting-weblog-to-google-app-engine/</guid>
      <description>

&lt;p&gt;ここ数日というもの、Mac の前に座ってやっていたことといえば、&lt;a href=&#34;http://twitter.com/takanori_is&#34;&gt;Twitter&lt;/a&gt; か RSS フィードの消化か、でなければブログの移行作業だ。&lt;/p&gt;

&lt;p&gt;もともと、このブログは &lt;a href=&#34;http://wordpress.org/&#34;&gt;Wordpress&lt;/a&gt; で運営していたのだが、色々と不満もたまってきたので、いつの日かつくりなおしたい、と思っていた。おりしも &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; の勉強をはじめたばかりである。ちょうどよい。教材代わりに簡単なブログシステムを細々とつくっていた。&lt;/p&gt;

&lt;p&gt;それを更に、&lt;a href=&#34;http://code.google.com/appengine/&#34;&gt;Google App Engine&lt;/a&gt; に移植しましたよ、というのが今回のお話。&lt;/p&gt;

&lt;h3 id=&#34;google-app-engine-に移植した理由&#34;&gt;Google App Engine に移植した理由&lt;/h3&gt;

&lt;p&gt;まずは、Google App Engine（以下、GAE）に移植した理由から説明させてほしい。いままで Wordpress を動かしていたサーバでそのまま新しいブログシステムを動かすこともできた。&lt;/p&gt;

&lt;p&gt;それでも、わざわざ時間を割いてまで GAE に移植したのは、GAE が話題になってるとか、Django が使えるらしい、というのも重要だったが、&lt;strong&gt;自宅サーバの管理から解放されたい&lt;/strong&gt; 、という理由が実は一番大きい。&lt;/p&gt;

&lt;p&gt;うん、自宅サーバの、しかも個人ブログの管理の手間なんて、たかがしれている（そりゃ、セキュリティとかは神経使うけどさ）。それよりは今後、もし、転居や契約している回線業者を変更する場合を考えると、そのあいだは自宅サーバは停めなきゃならないわけで、いまのうちに GAE に移植しておけば、あとあと困らないだろう、というわけである。&lt;/p&gt;

&lt;p&gt;実際の移植作業には 4 日程度を要した。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://code.google.com/appengine/docs/&#34;&gt;GAE のオンラインドキュメント&lt;/a&gt; を参考に、ほとんど単純作業による変換だったが、細かい変更や思わぬ問題などもあったので、開発中にとったメモを片手につらつらと書いてみる。&lt;/p&gt;

&lt;h3 id=&#34;django&#34;&gt;Django&lt;/h3&gt;

&lt;p&gt;Django は &lt;a href=&#34;http://code.google.com/appengine/articles/django.html&#34;&gt;Running Django on Google App Engine&lt;/a&gt; を参考に、開発版のものを動かしている。&lt;/p&gt;

&lt;p&gt;GAE では Django の &lt;a href=&#34;http://www.djangoproject.com/documentation/db-api/&#34;&gt;Database API&lt;/a&gt;（&lt;a href=&#34;http://ymasuda.jp/python/django/docs/db-api.html&#34;&gt;和訳&lt;/a&gt;）は動作せず、GAE の &lt;a href=&#34;http://code.google.com/appengine/docs/datastore/&#34;&gt;Datastore API&lt;/a&gt; を使う必要があるが、当然の帰結として、Database API に依存した機能やアドオンも使えない。Django の売りのひとつである &lt;a href=&#34;http://www.djangobook.com/en/1.0/chapter06/&#34;&gt;Admin Interface&lt;/a&gt; も、サイトマップを手軽に生成できる &lt;a href=&#34;http://www.djangoproject.com/documentation/sitemaps/&#34;&gt;Sitemap framework&lt;/a&gt; も、&lt;a href=&#34;http://www.djangoproject.com/documentation/generic_views/&#34;&gt;Generic View&lt;/a&gt; でさえ使えない。また、Sites も &lt;a href=&#34;http://www.djangoproject.com/documentation/sites/#requestsite-objects&#34;&gt;RequestSite オブジェクトで代替&lt;/a&gt;してやらなくてはいけない。&lt;/p&gt;

&lt;p&gt;ただ、Generic View は簡単な変更で動きそうだ。実際、&lt;a href=&#34;http://www.djangoproject.com/documentation/pagination/&#34;&gt;Pagination&lt;/a&gt; の処理では &lt;code&gt;django.core.QuerySetPaginator&lt;/code&gt; に GAE の &lt;a href=&#34;http://code.google.com/appengine/docs/datastore/queryclass.html&#34;&gt;Query&lt;/a&gt; オブジェクトをそのまま渡して動作していた（GAE の Query オブジェクトも &lt;code&gt;[]&lt;/code&gt; アクセスを適切な &lt;code&gt;fetch()&lt;/code&gt; に変換してくれる）。&lt;/p&gt;

&lt;h3 id=&#34;akismet&#34;&gt;Akismet&lt;/h3&gt;

&lt;p&gt;スパムコメント対策として &lt;a href=&#34;http://www.hashcash.org/&#34;&gt;Hashcash&lt;/a&gt; と &lt;a href=&#34;http://akismet.com/&#34;&gt;Akismet&lt;/a&gt; を使っているのだが、外部リソースへのアクセスは GAE の &lt;a href=&#34;http://code.google.com/appengine/docs/urlfetch/&#34;&gt;URL Fetch API&lt;/a&gt; に変更が必要だ。Akismet への問い合わせ処理は、外部リソースへのアクセスなので URL Fetch API を使うように変更が必要だった。&lt;/p&gt;

&lt;h3 id=&#34;docutils-pygments&#34;&gt;docutils, pygments&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docutils.sourceforge.net/rst.html&#34;&gt;reStructuredText&lt;/a&gt; でブログを書くために &lt;a href=&#34;http://docutils.sourceforge.net/&#34;&gt;docutils&lt;/a&gt; を、そして、ソースコードのハイライトするために &lt;a href=&#34;http://pygments.org/&#34;&gt;pygments&lt;/a&gt; をソースコードに含めるようにした（トップレベルだと邪魔なので、&lt;code&gt;lib&lt;/code&gt; というディレクトリにパスを通して、そこに必要なライブラリを置くようにした）。&lt;/p&gt;

&lt;p&gt;また、docutils はそのままだと、一部 GAE で禁止されているファイルシステム関連の API を使っている。&lt;code&gt;docutils/frontend.py&lt;/code&gt; の&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if read_config_files and not self.defaults[&#39;_disable_config&#39;]:
    try:
        config_settings = self.get_standard_config_settings()
    except ValueError, error:
        self.error(error)
    self.set_defaults(**config_settings.__dict__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この部分は潔くコメントアウトした。&lt;/p&gt;

&lt;h3 id=&#34;検索機能&#34;&gt;検索機能&lt;/h3&gt;

&lt;p&gt;モデルクラスで db.Model ではなく、そのサブクラスである google.appengine.ext.search.SearchableModel を継承することで、モデルの検索ができるようになるようだ（&lt;a href=&#34;http://groups.google.com/group/google-appengine/browse_thread/thread/ba4a4a4ccefb96c5/0e3f0ab63c4c8afd&#34;&gt;Indexing Large Chunks of Text for Search - Google App Engine | Google グループ&lt;/a&gt; を参照）。「検索機能を備えたクラスを継承する」というだけでもダサいのに、日本語での使用とか不安なので、検索機能はとりあえず見送った。&lt;/p&gt;

&lt;h3 id=&#34;デプロイして直面した問題&#34;&gt;デプロイして直面した問題&lt;/h3&gt;

&lt;p&gt;Web アプリケーションの宿命で、最大の問題はデプロイ後にやってくる。&lt;/p&gt;

&lt;p&gt;デプロイ直後はすぐに CPU 制限にひっかかってしまう
理由は分からないが、デプロイ直後は GAE の CPU 制限によるエラーが頻発した。これくらいの処理でもういっぱいなのか、と萎えかけたが、しばらくすると正常に動作するようになった。なので、これからもし、同じ現象に遭われた方は、静かな心で見守るのがよいと思う。&lt;/p&gt;

&lt;p&gt;データベースの制限でデータ移行ができない
以前のブログからのデータ移行は、dump したデータベースからデータを投入する Python スクリプトを生成する移行スクリプトを用意していた（&lt;a href=&#34;http://code.google.com/appengine/articles/bulkload.html&#34;&gt;CSV を使う手段&lt;/a&gt;もあるようだが、こっちの方がオブジェクト間の関連を再現するのも楽だ）。&lt;/p&gt;

&lt;p&gt;しかし、&lt;strong&gt;これが動かない&lt;/strong&gt;。一度に保存するデータが多すぎると制限にひっかかってエラーになるらしい。&lt;/p&gt;

&lt;p&gt;解決策としては、移行処理を機械的に関数に分割して、一度のリクエストでひとつの関数を呼ぶように変更、外部からスクリプトで順番にアクセスさせるようにした。現実の素晴らしき泥臭さ。&lt;/p&gt;

&lt;p&gt;favicon.ico と robots.txt の設定
些細なことかもしれないが、favicon.ico と robots.txt の設定をしていなかったせいで、404 エラーが大量に発生してしまった。&lt;a href=&#34;http://d.hatena.ne.jp/technohippy/20080412#1207983599&#34;&gt;Google App Engineでfaviconを設定する&lt;/a&gt;を参考に &lt;code&gt;app.yaml&lt;/code&gt; を設定した。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- url: /favicon.ico
  static_files: public/favicon.ico
  upload: public/favicon\.ico
- url: (.*?)/robots.txt
  static_files: public/robots.txt
  upload: public/robots\.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;gae-にしてよかったこと-不満&#34;&gt;GAE にしてよかったこと・不満&lt;/h3&gt;

&lt;p&gt;最後に感想でも。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;デプロイも管理も楽&lt;/li&gt;
&lt;li&gt;思ったよりも速い&lt;/li&gt;
&lt;li&gt;独自ドメインの設定も簡単だった&lt;/li&gt;
&lt;li&gt;ログの管理や分析とか見過ごしがちな点でもあるので地味に助かる&lt;/li&gt;
&lt;li&gt;管理インターフェースはまだまだ（特に Django の管理インターフェースを期待していた身としてはつらい）&lt;/li&gt;
&lt;li&gt;ひとつの閉じた世界をいじくってる楽しさがある&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最後の点について補足。必要なライブラリはバンドルしなければならないが、それ以外の部分（サーバ管理とか、ミドルウェアとか、ログとか）は無視してアプリケーションの開発に集中できる、という意味で「ひとつの閉じた世界をいじくってる楽しさ」を感じた。そういうこと。&lt;/p&gt;

&lt;p&gt;あと 2 つアプリケーション作れるらしいので、何かネタを思いついたら挑戦してみたいですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Django のテンプレートでフォームの要素が hidden かどうかを調べる</title>
      <link>http://www.metareal.org/2008/05/12/checking-whether-field-has-a-hidden-widget-in-django-template/</link>
      <pubDate>Mon, 12 May 2008 10:37:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/05/12/checking-whether-field-has-a-hidden-widget-in-django-template/</guid>
      <description>&lt;p&gt;Django の &lt;a href=&#34;http://www.djangoproject.com/documentation/newforms/&#34;&gt;newforms library&lt;/a&gt; は、それだけでちいさな MVC の世界だ。テキストフィールドやラジオボタンといった View は &lt;code&gt;django.newforms.widgets&lt;/code&gt; の Widget クラスとそのサブクラスが担当している。&lt;/p&gt;

&lt;p&gt;フォーム要素の HTML をテンプレートで出力する簡単な例は以下のとおり。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;&amp;quot;&amp;gt;
{% for field in form %}
    {{ field.label_tag }}
    {{ field }}&amp;lt;br /&amp;gt;
{% endfor %}
&amp;lt;input type=&amp;quot;submit&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、このままだと hidden 要素でも &lt;label&gt; が出力されて具合が悪い。&lt;/p&gt;

&lt;p&gt;実は、&lt;code&gt;Widget&lt;/code&gt; クラスには &lt;code&gt;is_hidden&lt;/code&gt; という、その要素が hidden 要素の場合は &lt;code&gt;True&lt;/code&gt; を返すメソッドが定義されているので、テンプレート中でこれをチェックすればいい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;&amp;quot;&amp;gt;
{% for field in form %}
    {% if field.field.widget.is_hidden %}
        {{ field }}
    {% else %}
        {{ field.label_tag }}
        {{ field }}&amp;lt;br /&amp;gt;
    {% endif %}
{% endfor %}
&amp;lt;input type=&amp;quot;submit&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ひとつだけ注意。&lt;a href=&#34;http://www.djangoproject.com/documentation/newforms/#highlighting-required-fields-in-templates&#34;&gt;ドキュメント&lt;/a&gt;にも書かれているように、ここでの &lt;code&gt;field&lt;/code&gt; は &lt;code&gt;newforms.forms.BoundField&lt;/code&gt; なので、実際の &lt;code&gt;Field&lt;/code&gt; インスタンスを調べる場合は &lt;code&gt;field.field&lt;/code&gt; とする必要がある。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Django の urlresolvers.py を読む</title>
      <link>http://www.metareal.org/2008/04/22/django-code-reading-core-urlresolvers/</link>
      <pubDate>Tue, 22 Apr 2008 10:38:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/04/22/django-code-reading-core-urlresolvers/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://lifecoding.metareal.org/post/32387415&#34;&gt;一身上の都合&lt;/a&gt;により &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; の &lt;a href=&#34;http://www.djangoproject.com/documentation/url_dispatch/&#34;&gt;URL dispatcher&lt;/a&gt; について調べている。ドキュメントでだいたいの動作は把握したので、今回は &lt;code&gt;urls.py&lt;/code&gt; に定義した URL のマッピングが実際にはどのように解決されているのか、ソースコードを読むことで理解を深めたい、と思う。&lt;/p&gt;

&lt;p&gt;なお、参照したソースコードは SVN の Revision 7438 である。公開リリースの 0.96.1 とは内容が大きく異なる可能性があること、 &lt;a href=&#34;http://code.djangoproject.com/query&#34;&gt;Trac&lt;/a&gt; での議論やドキュメントを読むかぎり、このへんの実装については今後大きく変更されるかもしれないことを、あらかじめお断りしておく。&lt;/p&gt;

&lt;h3 id=&#34;urlresolvers-py&#34;&gt;urlresolvers.py&lt;/h3&gt;

&lt;p&gt;まずは、調べるソースコードを特定しよう。URL の逆マッピングをしてくれる &lt;a href=&#34;http://www.djangoproject.com/documentation/url_dispatch/#reverse&#34;&gt;reverse() 関数&lt;/a&gt;が用意されていることは分かっているので、これを手がかりにソースコードを探すのがよさそうだ。&lt;/p&gt;

&lt;p&gt;試しに &lt;code&gt;def reverse(&lt;/code&gt; を検索してみると、簡単に見つかった。&lt;code&gt;django/core/urlresolvers.py&lt;/code&gt; で定義されている。ソースコードのコメントにも、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This module converts requested URLs to callback view functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;と書かれているので、これが探していたソースコード（モジュール）だろう。&lt;/p&gt;

&lt;h3 id=&#34;reverse-と-resolve&#34;&gt;reverse() と resolve()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;urlresolvers.py&lt;/code&gt; では &lt;code&gt;reverse()&lt;/code&gt; だけでなく、&lt;code&gt;resolve()&lt;/code&gt; も定義されている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def resolve(path, urlconf=None):
    return get_resolver(urlconf).resolve(path)

def reverse(viewname, urlconf=None, args=None, kwargs=None):
    args = args or []
    kwargs = kwargs or {}
    return iri_to_uri(u&#39;/&#39; + get_resolver(urlconf).reverse(viewname, *args, **kwargs))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数名や引数から &lt;code&gt;reverse()&lt;/code&gt; が URL の逆マッピング（名前、引数から URL を探索）を行うのにたいし、&lt;code&gt;resolve()&lt;/code&gt; が URL のマッピング（URL から探索）を担当していることは容易に想像がつく。&lt;/p&gt;

&lt;p&gt;では、&lt;code&gt;resolve()&lt;/code&gt; が返すものはなんだろうか？　これはソースコードのコメントに書いてある。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This module converts requested URLs to callback view functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RegexURLResolver is the main class here. Its resolve() method takes a URL (as
a string) and returns a tuple in this format:&lt;/p&gt;

&lt;p&gt;(view_function, function_args, function_kwargs)&lt;/p&gt;

&lt;p&gt;アクセスされた URL パス文字列を渡すと、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;View 関数&lt;/li&gt;
&lt;li&gt;引数&lt;/li&gt;
&lt;li&gt;キーワード引数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;がタプルで返ってくるらしい。&lt;/p&gt;

&lt;h3 id=&#34;regexurlresolver&#34;&gt;RegexURLResolver&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;reverse()&lt;/code&gt; も &lt;code&gt;resolve()&lt;/code&gt; も、実際の処理は &lt;code&gt;get_resolver()&lt;/code&gt; で返ってくるオブジェクトに丸投げしている。そして、先のコメントが示唆するように、&lt;code&gt;get_resolver()&lt;/code&gt; で返されるオブジェクトは &lt;code&gt;RegexURLResolver&lt;/code&gt; のインスタンスになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def get_resolver(urlconf):
...
    return RegexURLResolver(r&#39;^/&#39;, urlconf)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RegexURLResolver&lt;/code&gt; は &lt;code&gt;urls.py&lt;/code&gt; に対応したクラスであり、そこで定義された &lt;code&gt;urlpatterns&lt;/code&gt; や &lt;code&gt;handler404&lt;/code&gt; などを参照している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class RegexURLResolver(object):
...
    def _get_urlconf_module(self):
        try:
            return self._urlconf_module
        except AttributeError:
            try:
                self._urlconf_module = __import__(self.urlconf_name, {}, {}, [&#39;&#39;])
...
    def _get_url_patterns(self):
        return self.urlconf_module.urlpatterns
...
    def _resolve_special(self, view_type):
        callback = getattr(self.urlconf_module, &#39;handler%s&#39; % view_type)
...
    def resolve404(self):
        return self._resolve_special(&#39;404&#39;)

    def resolve500(self):
        return self._resolve_special(&#39;500&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、&lt;code&gt;urlpatterns&lt;/code&gt; の中身は何かといえば、同じファイルで定義されている &lt;code&gt;RegexURLPattern&lt;/code&gt; インスタンスのリストだ（ただし、別の &lt;code&gt;urls.py&lt;/code&gt; を &lt;code&gt;include()&lt;/code&gt; している場合は &lt;code&gt;RegexURLPattern&lt;/code&gt; ではなく &lt;code&gt;RegexURLResolver&lt;/code&gt; インスタンスがリストに挿入されて入れ子構造になる）。このへんは patterns() や url() が定義されている &lt;code&gt;django/conf/defaults.py&lt;/code&gt; を読むと分かる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;resolve()&lt;/code&gt; メソッドの実装を見れば、URL パス文字列の対応を &lt;code&gt;urlpatterns&lt;/code&gt; から探索する様子が分かるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def resolve(self, path):
    tried = []
    match = self.regex.search(path)
    if match:
        new_path = path[match.end():]
        for pattern in self.urlconf_module.urlpatterns:
            try:
                sub_match = pattern.resolve(new_path)
            except Resolver404, e:
                tried.extend([(pattern.regex.pattern + &#39;   &#39; + t) for t in e.args[0][&#39;tried&#39;]])
            else:
                if sub_match:
                    sub_match_dict = dict([(smart_str(k), v) for k, v in match.groupdict().items()])
                    sub_match_dict.update(self.default_kwargs)
                    for k, v in sub_match[2].iteritems():
                        sub_match_dict[smart_str(k)] = v
                    return sub_match[0], sub_match[1], sub_match_dict
                tried.append(pattern.regex.pattern)
        raise Resolver404, {&#39;tried&#39;: tried, &#39;path&#39;: new_path}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;resolve()&lt;/code&gt; メソッドは &lt;code&gt;RegexURLPattern&lt;/code&gt; にも &lt;code&gt;RegexURLResolver&lt;/code&gt; にも実装されていることに注意。&lt;/p&gt;

&lt;h3 id=&#34;matchchecker&#34;&gt;MatchChecker&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;urlresolver.py&lt;/code&gt; にはこの他に &lt;code&gt;MatchChecker&lt;/code&gt; というクラスが定義されており、これは &lt;code&gt;reverse()&lt;/code&gt; の過程で正規表現をパス文字列に変換するために使われているようだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def reverse_helper(regex, *args, **kwargs):
...
    # TODO: Handle nested parenthesis in the following regex.
    result = re.sub(r&#39;\(([^)]+)\)&#39;, MatchChecker(args, kwargs), regex.pattern)
    return result.replace(&#39;^&#39;, &#39;&#39;).replace(&#39;$&#39;, &#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;余談だが、ここでは &lt;code&gt;^&lt;/code&gt; と &lt;code&gt;$&lt;/code&gt; のメタ文字しか削除していないため、他のメタ文字はそのまま残ってしまう（もっとも、通常のマッピングをする範囲で困ることはないだろうけど）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Django と Python-Markdown 1.7 で UnicodeDecodeError</title>
      <link>http://www.metareal.org/2008/04/14/python-markdown-1-7-with-django/</link>
      <pubDate>Tue, 15 Apr 2008 08:57:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/04/14/python-markdown-1-7-with-django/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.freewisdom.org/projects/python-markdown/&#34;&gt;Python Markdown&lt;/a&gt; の最新版である 1.7 を &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; で使うと、日本語など ASCII 以外の文字で UnicodeDecodeError が発生する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MARKDOWN-CRITICAL: &amp;quot;UnicodeDecodeError: Markdown only accepts unicode or ascii  input.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すでに&lt;a href=&#34;http://code.djangoproject.com/ticket/6387&#34;&gt;チケットも登録されている&lt;/a&gt;が、とりあえず古いバージョンに戻すのがよさそう。&lt;a href=&#34;http://code.djangoproject.com/ticket/5663#comment:1&#34;&gt;1.6b はバグで同様のエラーが出る&lt;/a&gt;ようなので、1.6a にしよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% sudo easy_install markdown==1.6a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;蛇足だが、この問題を調べている途中で見つけた。&lt;a href=&#34;http://code.google.com/p/python-markdown2/&#34;&gt;python-markdown2&lt;/a&gt; という、別の Markdown ライブラリも存在するようだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Django のモデルで日本語を使うと UnicodeEncodeError が発生する</title>
      <link>http://www.metareal.org/2008/04/11/django-unicode-encode-error/</link>
      <pubDate>Sat, 12 Apr 2008 07:16:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/04/11/django-unicode-encode-error/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://diary.metareal.org/2008/01/24/meet-django-django-is-a-high-level-python-web-framework/&#34;&gt;ちょっと前&lt;/a&gt;から &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; で遊んでいる。教則本代わりの &lt;a href=&#34;http://www.djangobook.com/&#34;&gt;Django Book&lt;/a&gt; も含めて、完成度の高さに驚くことしきり。&lt;/p&gt;

&lt;p&gt;ただ、実際に管理インターフェースでモデルの詳細を表示しようとすると、&lt;strong&gt;UnicodeEncodeError&lt;/strong&gt; とかいう嫌らしいエラーが出て、萎える。&lt;/p&gt;

&lt;p&gt;しかたなく &lt;code&gt;python UnicodeEncodeError django&lt;/code&gt; で検索したら &lt;a href=&#34;http://d.hatena.ne.jp/SumiTomohiko/20070120/1169300624&#34;&gt;sitecustomize.py でデフォルトのエンコーディングを変更する&lt;/a&gt;とか、いや、str 関数に渡したい場合はそりゃそうなんだろうけど、せっかくフレームワーク使ってるんだし、この解決法じゃないんだろうな、っていうのしか見つけられなくてますます萎えてたわけだけど、やっと納得できる解決法が見つかったので残しておく。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;#id1&#34;&gt;``&lt;/a&gt;svn trunk`` な Django を使っている。&lt;/p&gt;

&lt;p&gt;System Message: WARNING/2 (&lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, line 7); &lt;em&gt;backlink&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Inline literal start-string without end-string.&lt;/p&gt;

&lt;h3 id=&#34;モデルには-str-ではなく-unicode-を実装する&#34;&gt;モデルには &lt;strong&gt;str&lt;/strong&gt; ではなく &lt;strong&gt;unicode&lt;/strong&gt; を実装する&lt;/h3&gt;

&lt;p&gt;Django オンラインドキュメント和訳の &lt;a href=&#34;http://michilu.com/django/doc-ja/unicode/#str-unicode&#34;&gt;&lt;strong&gt;str&lt;/strong&gt;() と &lt;strong&gt;unicode&lt;/strong&gt;() のどちらを使うべきか&lt;/a&gt;に、そのものズバリの回答があった。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;モデルに &lt;strong&gt;str&lt;/strong&gt;() メソッドを定義する代わりに &lt;strong&gt;unicode&lt;/strong&gt;() メソッドを実装するよう推奨します． &lt;strong&gt;unicode&lt;/strong&gt;() メソッ ドの中では，モデルのフィールド値を使って好きな値を作成でき，その値がバイト 文字列として適切に表現されるかを気にせず返してかまいません&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本当だ。モデルに書いていた &lt;strong&gt;str&lt;/strong&gt; メソッドを &lt;strong&gt;unicode&lt;/strong&gt; に変えるだけで解決しちゃったよ。&lt;/p&gt;

&lt;h3 id=&#34;force-unicode&#34;&gt;force_unicode&lt;/h3&gt;

&lt;p&gt;エラーのスタックトレースを辿って、Django の &lt;code&gt;django/utils/encodings.py&lt;/code&gt; を見てみると、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def force_unicode(s, encoding=&#39;utf-8&#39;, strings_only=False, errors=&#39;strict&#39;):
...
        if not isinstance(s, basestring,):
            if hasattr(s, &#39;__unicode__&#39;):
                s = unicode(s)
            else:
                s = unicode(str(s), encoding, errors)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーは最後の str 関数の呼び出しで起きているわけだが、その前に hasattr で &lt;strong&gt;unicode&lt;/strong&gt; を調べているのが分かると思う。実をいうと上のドキュメントは、ここから &lt;strong&gt;unicode&lt;/strong&gt; を検索してみて見つけたものだった。&lt;/p&gt;

&lt;p&gt;しかし、改めて検索してみると常識っぽいな&amp;hellip;。最初の検索の仕方がまずかったか。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>