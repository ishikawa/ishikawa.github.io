<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>METAREAL</title>
    <link>http://www.metareal.org/tags/google/index.xml</link>
    <description>Recent content on METAREAL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <copyright>copyright © 2006-Present Takanori Ishikawa.</copyright>
    <atom:link href="http://www.metareal.org/tags/google/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Google Bookmark が快適すぎる</title>
      <link>http://www.metareal.org/2010/02/23/google-bookmark-makes-me-feel-so-good/</link>
      <pubDate>Tue, 23 Feb 2010 23:26:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2010/02/23/google-bookmark-makes-me-feel-so-good/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.google.com/bookmarks/&#34;&gt;Google Bookmark&lt;/a&gt; を使いはじめた。シンプルながら快適な使い心地で気に入っている。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;とにかく、ブックマーク編集画面が開くまでが速い&lt;/li&gt;
&lt;li&gt;ブックマーク先のページも含めて全文検索が可能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ソーシャル要素は考えず、純粋に「ブックマーク」という行為を突き詰めていくと、上記二点が非常に重要であることが分かると思う。&lt;/p&gt;

&lt;p&gt;ちなみに、ブックマークレットには&lt;a href=&#34;http://winmac.blog33.fc2.com/blog-entry-63.html&#34;&gt;Googleブックマークに追加するブックマークレット（メモ欄対応版）&lt;/a&gt;で配布されているものを別窓で開くようにして使わせてもらっている。感謝。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javascript:var%20u=encodeURIComponent(location.href);var%20ti=encodeURIComponent(document.title);var%20te=encodeURIComponent((window.getSelection&amp;amp;&amp;amp;window.getSelection())||(document.getSelection&amp;amp;&amp;amp;document.getSelection())||(document.selection&amp;amp;&amp;amp;document.selection.createRange&amp;amp;&amp;amp;document.selection.createRange().text));window.open((te!=&#39;&#39;)?&#39;http://www.google.com/bookmarks/mark?op=add&amp;amp;bkmk=&#39;+u+&#39;&amp;amp;title=&#39;+ti+&#39;&amp;amp;annotation=&#39;+te:&#39;http://www.google.com/bookmarks/mark?op=add&amp;amp;bkmk=&#39;+u+&#39;&amp;amp;title=&#39;+ti);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Go</title>
      <link>http://www.metareal.org/2009/11/11/go-vim/</link>
      <pubDate>Wed, 11 Nov 2009 10:29:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2009/11/11/go-vim/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://iolanguage.com/&#34;&gt;Io&lt;/a&gt; と並んで、自らの検索能力が試される名前の &lt;a href=&#34;http://golang.org/&#34;&gt;Go&lt;/a&gt; ですが、実用性と簡潔さを兼ねそなえた言語設計は好感がもてます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% cd $GOROOT
% ls misc/vim/
go.vim
% cp misc/vim/go.vim ~/.vim/syntax/
% cat &amp;amp;gt; ~/.vim/ftdetect/go.vim
au BufRead,BufNewFile *.go set filetype=go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今日はここまで。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google Chrome に搭載されたオープンソースの JavaScript エンジン &#34;v8&#34; を試す</title>
      <link>http://www.metareal.org/2008/09/03/getting-started-with-v8-google-open-source-javascript-engine/</link>
      <pubDate>Wed, 03 Sep 2008 09:28:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2008/09/03/getting-started-with-v8-google-open-source-javascript-engine/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://googlejapan.blogspot.com/2008/09/blog-post.html&#34;&gt;その発表&lt;/a&gt;から世間を騒がせた、Google の Web ブラウザ &lt;strong&gt;Chrome&lt;/strong&gt; が遂に&lt;a href=&#34;http://www.google.com/chrome&#34;&gt;公開された&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Mac ユーザなうえに、日々の Web ブラウジングは Safari と iPhone で満足していることもあり、Chrome 自体への興味は薄い。しかし、オープンソースの JavaScript エンジンも独自開発している、となると話は別だ。しかも、&lt;a href=&#34;http://www.strongtalk.org/&#34;&gt;Strongtalk&lt;/a&gt; や &lt;a href=&#34;http://java.sun.com/javase/technologies/hotspot/&#34;&gt;HotSpot Java VM&lt;/a&gt; の開発者が関わっている、というのだから俄然興味が湧いてくる（&lt;a href=&#34;http://www.avibryant.com/2008/09/chrome-v8-and-s.html&#34;&gt;参考記事&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;Google が開発、公開している JavaScript 処理系は、その名も &lt;a href=&#34;http://code.google.com/p/v8/&#34;&gt;v8&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;v8-の特徴&#34;&gt;v8 の特徴&lt;/h3&gt;

&lt;p&gt;では、v8 には既存の処理系に比べて、どのような利点があるのだろうか。Google がわざわざ独自に開発し、Chrome という重要なプロダクトに搭載して公開するくらいだから、そこには他の処理系では達成できないアドバンテージがあるはずである。&lt;/p&gt;

&lt;p&gt;Google Code で公開されている文書 &lt;a href=&#34;http://code.google.com/apis/v8/design.html&#34;&gt;Design Elements&lt;/a&gt; から概観をつかんでみよう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://code.google.com/apis/v8/design.html#prop_access&#34;&gt;オブジェクトのプロパティへのアクセスが高速&lt;/a&gt;
JavaScript ではオブジェクトのプロパティを自由に追加・削除できる。&lt;/p&gt;

&lt;p&gt;これを実現するためには、ハッシュ表や二分木といった&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E9%80%A3%E6%83%B3%E9%85%8D%E5%88%97&#34;&gt;辞書&lt;/a&gt;による実装が一般的だが、そうするとプロパティにアクセスするたびに辞書を検索しなくてはいけない。&lt;/p&gt;

&lt;p&gt;v8 では &lt;strong&gt;hidden class&lt;/strong&gt; という実装テクニックを用いることにより、オブジェクトのプロパティへのアクセス方法が、オブジェクトの格納されているメモリのオフセットへのアクセスとなる。そのため、無駄な検索を省くことができ、高速なアクセスを実現している。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://code.google.com/apis/v8/design.html#mach_code&#34;&gt;動的なマシンコード生成&lt;/a&gt;
JavaScript のコードは最初に実行されるときにマシンコードに変換される。&lt;strong&gt;バイトコードやインタプリタはない&lt;/strong&gt;。また、プロパティへのアクセスは特別扱いされ、インライン・キャッシュという Smalltalk 実装系由来の技法が使われているらしい（参考：&lt;a href=&#34;http://www.cs.ucla.edu/~palsberg/course/cs232/papers/DeutschSchiffman-popl84.pdf&#34;&gt;Efficient Implementation of the Smalltalk-80 System&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://code.google.com/apis/v8/design.html#garb_coll&#34;&gt;効率的なガベージコレクション&lt;/a&gt;
v8 のガベージコレクションの特徴は以下のとおりである：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stop-the-world&lt;/strong&gt; ガベージコレクション中はプログラムが停止する&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;世代別ガベージコレクション&lt;/strong&gt; 一度のガベージコレクションではオブジェクトの一部のみを検査することにより、プログラム停止時間を短縮&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ldquo;保守的&amp;rdquo;ではない&lt;/strong&gt; このため、未使用のオブジェクトをポインタと判定してしまい、メモリリークすることがない&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;メモリ・コンパクションができる&lt;/strong&gt; メモリのフラグメンテーションを防ぐ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;総じて、バランスの良い実装を選びながら、特にメモリ効率に気をつかっている印象を受ける。&lt;/p&gt;

&lt;h3 id=&#34;試す&#34;&gt;試す&lt;/h3&gt;

&lt;p&gt;どうだろう？ v8 に興味が湧いてきたんじゃないだろうか。&lt;/p&gt;

&lt;p&gt;では、能書きはこれくらいにして、実際に v8 を使ってみよう。なお、環境は Mac OS X Leopard、Xcode はインストール済みで GCC, Python, Subversion などがインストールされているものとする。&lt;/p&gt;

&lt;p&gt;まずは適当なディレクトリに、ソースコードをチェックアウトする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% cd Developer/Workspace/JavaScript/
% svn checkout http://v8.googlecode.com/svn/trunk/ v8
% cd v8/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドには &lt;a href=&#34;http://www.scons.org/&#34;&gt;SCons&lt;/a&gt; というビルドツールが必要だ。&lt;a href=&#34;http://www.macports.org/&#34;&gt;MacPorts&lt;/a&gt; でインストールしておこう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% sudo port install scons
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドオプションは、&lt;code&gt;scons --help&lt;/code&gt; で確認できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% scons --help
scons: Reading SConscript files ...
scons: done reading SConscript files.

mode: compilation mode (debug, release)
    default: release
    actual: release

sample: build sample (shell, process)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とりあえず試したいだけなので、デフォルトの設定でビルドしてみようか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% scons
scons: Reading SConscript files ...
scons: done reading SConscript files.
scons: Building targets ...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じディレクトリに &lt;code&gt;libv8.a&lt;/code&gt; というライブラリができたはずだ。&lt;/p&gt;

&lt;h3 id=&#34;簡単な-c-プログラムで使ってみよう&#34;&gt;簡単な C++ プログラムで使ってみよう&lt;/h3&gt;

&lt;p&gt;他の C++ プログラムに組み込んで使うことを念頭に開発されているのも、v8 の特徴だ。プロジェクト・サイトにある &lt;a href=&#34;http://code.google.com/apis/v8/get_started.html&#34;&gt;Hello World プログラム&lt;/a&gt;よりは実用的なプログラムで感触をつかんでみよう。&lt;/p&gt;

&lt;p&gt;以下は、標準入力から受け取ったプログラムを構文解析して実行、結果を標準出力に書き出すプログラムだ（Gist にもアップしておいた。&lt;a href=&#34;http://gist.github.com/8559&#34;&gt;gist:8559&lt;/a&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;v8.h&amp;gt;

using namespace v8;

int main(int argc, const char **argv) {
  // Create a scope and environment
  HandleScope scope;
  Handle&amp;lt;Context&amp;gt; context = Context::New();
  Context::Scope context_scope(context);

  // Reading a source code
  std::stringbuf buffer;
  std::cin.get(buffer, EOF);
  Handle&amp;lt;String&amp;gt; source = String::New(buffer.str().c_str());

  // Register try/cache handler for error reporting
  TryCatch try_catch;
  // Compile the source code.
  Handle&amp;lt;Script&amp;gt; script = Script::Compile(source);

  if (script.IsEmpty()) {
    // Print errors that happened during compilation.
    String::AsciiValue error(try_catch.Exception());
    std::cout &amp;lt;&amp;lt; *error &amp;lt;&amp;lt; std::endl;
    return -1;
  }

  // Running script
  Handle&amp;lt;Value&amp;gt; result = script-&amp;gt;Run();

  if (result.IsEmpty()) {
    // Print errors that happened during execution.
    String::AsciiValue error(try_catch.Exception());
    std::cout &amp;lt;&amp;lt; *error &amp;lt;&amp;lt; std::endl;
    return -1;
  }

  // Convert the result to an ASCII string and print it.
  String::AsciiValue ascii(result);
  std::cout &amp;lt;&amp;lt; *ascii &amp;lt;&amp;lt; std::endl;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このプログラムは gcc で次のようにコンパイルする。&lt;code&gt;V8_HOME&lt;/code&gt; 環境変数には v8 をチェックアウトしたディレクトリを設定してほしい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% g++ -I${V8_HOME}/include -L${V8_HOME} -lv8 -o simple_v8_shell simple_v8_shell.cc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% ./simple_v8_shell
&#39;Hello, &#39; + &#39;World!&#39;
Hello, World!
% ./simple_v8_shell
1 + 2 * 3
7
% ./simple_v8_shell
var fib = function(n) {
  return (n &amp;lt; 2) ? n : fib(n - 2) + fib(n - 1)
}
fib(10)
55
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;最後に&#34;&gt;最後に&lt;/h3&gt;

&lt;p&gt;現時点では、v8 が実際のところどれだけのものなのか、確証をもって言えることは多くない。しかし、v8 の登場で強く感じたことがふたつある。&lt;/p&gt;

&lt;p&gt;まず、JavaScript エンジンの実装は &lt;a href=&#34;http://www.mozilla-japan.org/projects/tamarin/&#34;&gt;Tamarin&lt;/a&gt; (Adobe/Mozilla)、&lt;a href=&#34;http://webkit.org/blog/189/announcing-squirrelfish/&#34;&gt;SquirrelFish&lt;/a&gt; (Apple)、そして、今回の &lt;a href=&#34;http://code.google.com/p/v8/&#34;&gt;v8&lt;/a&gt; (Google) &amp;hellip; 強豪たちとホットな技術がひしめく戦場になりつつある。手の出尽くした感があるブラウザ競争とは異なり、この戦場はまさに「未開のフロンティア」だろう。&lt;/p&gt;

&lt;p&gt;また、ここ数年で多くのプログラマに浸透した動的言語だが、これから数年のうちに、今度は&lt;strong&gt;動的言語の効率的な実装&lt;/strong&gt;もプログラマ一般に浸透していくのではないか、という思いを強くした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google の検索履歴を記録する JavaScript を読んでみた</title>
      <link>http://www.metareal.org/2007/03/31/reading-google-search-history-javascript/</link>
      <pubDate>Sun, 01 Apr 2007 04:59:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/03/31/reading-google-search-history-javascript/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.google.com/searchhistory/&#34;&gt;Google 検索履歴&lt;/a&gt;では、検索クエリーの履歴だけではなく、検索結果で実際にどのページをクリックしたか、も記録している。&lt;/p&gt;

&lt;p&gt;検索結果ページのソースコードを読んでみると、履歴の保存は JavaScript で行われているようだ。&lt;/p&gt;

&lt;p&gt;改行やインデントを加えて読みやすくしたソースコードを基に、履歴を保存する処理や興味深い部分を紹介する。&lt;/p&gt;

&lt;h3 id=&#34;検索クエリーの保存&#34;&gt;検索クエリーの保存&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if (document.images) {
  new Image().src=&amp;quot;/url?sa=Q&amp;amp;client=safari&amp;amp;rls=ja-jp&amp;amp;q=...&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずは冒頭。新しい &lt;code&gt;Image&lt;/code&gt; を生成することで &lt;code&gt;http://www.google.com/url/&lt;/code&gt; にアクセスさせている。&lt;/p&gt;

&lt;p&gt;URL から推測するに検索クエリーを保存しているのだろう。&lt;/p&gt;

&lt;h3 id=&#34;クリックされたページの-url-を保存&#34;&gt;クリックされたページの URL を保存&lt;/h3&gt;

&lt;p&gt;クリックされたページの URL を保存する処理は、各リンクの &lt;code&gt;onmousedown&lt;/code&gt; に JavaScript を仕込むことで実現している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;...&amp;quot; class=l onmousedown=&amp;quot;return asq(event,this,&#39;&#39;,&#39;&#39;,&#39;res&#39;,&#39;1&#39;,&#39;&amp;amp;amp;sig2=...&#39;)&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リンクをクリックすると &lt;code&gt;asq&lt;/code&gt; 関数が実行されたのち、ページに遷移する、というわけだ。&lt;/p&gt;

&lt;h3 id=&#34;asq-関数の実装&#34;&gt;asq 関数の実装&lt;/h3&gt;

&lt;p&gt;では、&lt;code&gt;asq&lt;/code&gt; 関数はどのような実装になっているのだろう。それなりに長いので些末な部分は削除したソースは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.asq = function(d,a,f,g,k,l,m) {
  if (window.XMLHttpRequest) {
    var c = window.encodeURIComponent ? encodeURIComponent : escape;
    var h = &amp;quot;&amp;quot;, i = &amp;quot;&amp;quot;;
    var b = new XMLHttpRequest;
    var e = d.altKey || d.metaKey;

    b.open(
      &amp;quot;GET&amp;quot;,
      &amp;quot;/url?&amp;amp;url=&amp;quot;+c(a.href.replace(/#.*/,&amp;quot;&amp;quot;)).replace(/\+/g,&amp;quot;%2B&amp;quot;)+&amp;quot;&amp;amp;ei=...&amp;quot;+m,
      true);

    if (!e) {
      b.onreadystatechange = function() {
        if (b.readyState == 4) {
          clearTimeout(j);
          a.dispatchEvent(d)
        }
      };
      var j = setTimeout(function() {
                b.abort();
                a.dispatchEvent(d)
              },
              2000);
    }

    b.send(null);
    return e
  }
  return true
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt; を使って、クリックされたページの URL を非同期送信している。強調した部分では、&lt;code&gt;setTimeout&lt;/code&gt; でタイムアウト処理をしているようだ。&lt;/p&gt;

&lt;h3 id=&#34;ie-6-以下の場合は&#34;&gt;IE 6 以下の場合は？&lt;/h3&gt;

&lt;p&gt;見ての通り、&lt;code&gt;asq&lt;/code&gt; 関数の実装は &lt;code&gt;XMLHttpRequest&lt;/code&gt; オブジェクトがあるかどうかに依存している。&lt;/p&gt;

&lt;p&gt;では、&lt;code&gt;XMLHttpRequest&lt;/code&gt; オブジェクトではなく、&lt;code&gt;ActiveXObject&lt;/code&gt; 経由で非同期通信を行う IE 6 などではどうするのだろう？&lt;/p&gt;

&lt;p&gt;実は IE 6 などでアクセスすると、&lt;code&gt;asq&lt;/code&gt; 関数ではなく、&lt;code&gt;clk&lt;/code&gt; 関数というものが定義されるようになっている。この関数では検索クエリーの保存と同じように、&lt;code&gt;Image&lt;/code&gt; オブジェクトによるアクセスが行われている。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google のリダイレクタ</title>
      <link>http://www.metareal.org/2007/02/07/google-redirector/</link>
      <pubDate>Thu, 08 Feb 2007 01:15:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2007/02/07/google-redirector/</guid>
      <description>&lt;p&gt;社内の開発合宿行ったり、そこで風邪もらったりしているうちに、すっかりブログの更新から遠のいてしまった。ぼちぼち復活。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.2ch.net/&#34;&gt;2ちゃんねる&lt;/a&gt;ではリファラ隠しのために、いわゆる &lt;code&gt;ttp&lt;/code&gt; リンクや &lt;code&gt;http://ime.nu/&lt;/code&gt; などのリダイレクタが利用されている。リダイレクタという名前は勝手に使ってるだけで、正式なものか分からないけど、URL の末尾やパラメータに別の URL を指定すると、その URL にリダイレクトしてくれるページのこと。&lt;/p&gt;

&lt;p&gt;もっとも、&lt;code&gt;http://ime.nu/&lt;/code&gt; のように、あいだに警告ページを挟んでリンクを表示する（実際にはリダイレクトしない）ページもリダイレクタと呼んでいる。&lt;/p&gt;

&lt;p&gt;Google にも、このリダイレクタがあるのを、今日はじめて知った。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.google.com/url?sa=D&amp;amp;q=http://www.yahoo.co.jp/&#34;&gt;http://www.google.com/url?sa=D&amp;amp;q=http://www.yahoo.co.jp/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上の例は &lt;a href=&#34;http://www.yahoo.co.jp/&#34;&gt;http://www.yahoo.co.jp/&lt;/a&gt; に飛ばすためのリンク。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>