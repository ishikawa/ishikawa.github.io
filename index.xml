<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>METAREAL</title>
    <link>http://www.metareal.org/index.xml</link>
    <description>Recent content on METAREAL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <copyright>copyright © 2006-Present Takanori Ishikawa.</copyright>
    <lastBuildDate>Sun, 25 Sep 2016 14:47:00 +0900</lastBuildDate>
    <atom:link href="http://www.metareal.org/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Phoenix (Cowboy) の Gzip 圧縮サポート</title>
      <link>http://www.metareal.org/post/2016/09/gzip-compression-in-cowboy/</link>
      <pubDate>Sun, 25 Sep 2016 14:47:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/post/2016/09/gzip-compression-in-cowboy/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.phoenixframework.org&#34;&gt;Phoenix framework&lt;/a&gt; でレスポンスの GZip 圧縮を有効にするには
&lt;a href=&#34;https://github.com/ninenines/cowboy&#34;&gt;Cowboy&lt;/a&gt; に &lt;code&gt;compress: true&lt;/code&gt; を渡すように、
Phoenix.Endpoint を設定する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;config :example_app, ExampleApp.Endpoint,
  http: [port: 4040, compress: true],
  debug_errors: true,
  code_reloader: true,
  check_origin: false,
  watchers: []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTTP リクエストを送るときに &lt;code&gt;Accept-Encoding&lt;/code&gt; ヘッダーを設定する (&lt;code&gt;curl&lt;/code&gt; コマンドなら &lt;code&gt;--compressed&lt;/code&gt; オプション)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Accept-Encoding: gzip, deflate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、レスポンス・ボディのサイズが 300 バイトを超えていない場合も GZip 圧縮されないようだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ninenines/cowboy/commit/01f57ad65d7c75fb455f48e354bb3a328c472ce4#diff-2db000a0dd01503e2f022387f23413cbR942&#34;&gt;https://github.com/ninenines/cowboy/commit/01f57ad65d7c75fb455f48e354bb3a328c472ce4#diff-2db000a0dd01503e2f022387f23413cbR942&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>FileUtils in Rakefile</title>
      <link>http://www.metareal.org/post/2016/09/fileutils-in-rakefile/</link>
      <pubDate>Thu, 22 Sep 2016 19:26:18 +0900</pubDate>
      
      <guid>http://www.metareal.org/post/2016/09/fileutils-in-rakefile/</guid>
      <description>&lt;p&gt;いつまでたっても Rakefile の書き方を覚える気になれないのだが、Rakefile では
&lt;a href=&#34;https://docs.ruby-lang.org/ja/latest/class/FileUtils.html&#34;&gt;FileUtils&lt;/a&gt; が
インクルードされており &lt;code&gt;cp&lt;/code&gt; や &lt;code&gt;mkdir_p&lt;/code&gt; といったメソッドが使える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mkdir_p &amp;quot;dir1/dir2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、いくつかの拡張がされており、コマンドの実行が失敗したときに例外が投げられたり、&lt;code&gt;sh&lt;/code&gt; メソッドという
&lt;code&gt;Kernel.system&lt;/code&gt; にように外部コマンドを呼び出すメソッドが追加されている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/vzvu3k6k/items/7e6e5520eeb829ec1c8b&#34;&gt;Rakeのshで外部コマンドを実行する - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ruby/rake/blob/master/lib/rake/file_utils.rb&#34;&gt;rake/file_utils.rb at master · ruby/rake&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>docker build が固まる</title>
      <link>http://www.metareal.org/post/2015/12/hanging-up-docker-build/</link>
      <pubDate>Wed, 23 Dec 2015 12:49:25 +0900</pubDate>
      
      <guid>http://www.metareal.org/post/2015/12/hanging-up-docker-build/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; 試してるんですが&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「&lt;code&gt;docker build&lt;/code&gt; 遅すぎ！　コーヒー飲んでも終わってない！」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;さすがに遅すぎると思ったら、&lt;code&gt;Setting up ca-certificates-java (20130815ubuntu1) …&lt;/code&gt; と呟いたまま固まっていました。&lt;/p&gt;

&lt;p&gt;環境は以下の通り:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mac OS X El Capitan (10.11.2)&lt;/li&gt;
&lt;li&gt;VirtualBox 5.0.10 r104061&lt;/li&gt;
&lt;li&gt;Ubuntu 64bit (trusty)&lt;/li&gt;
&lt;li&gt;Docker 1.9.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/docker/docker/issues/18180&#34;&gt;Docker 1.9.1 hanging at build step &amp;ldquo;Setting up ca-certificates-java&amp;rdquo; · Issue #18180 · docker/docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AUFS のバグでデッドロックしているらしい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker info
…
Storage Driver: aufs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Issue のコメントを読む限り、Docker のバージョンを 1.9.0 以前に戻すのが確実そう。&lt;/p&gt;

&lt;p&gt;ただ、Docker のインストールは Vagrant の &lt;a href=&#34;https://docs.vagrantup.com/v2/provisioning/docker.html&#34;&gt;Docker Provisioner&lt;/a&gt; を利用していて、こいつでバージョン指定する方法が分からなかった（&lt;a href=&#34;https://github.com/mitchellh/vagrant/blob/1b08cfcd0945d1f7c2273d9c56d90a1e456d26aa/plugins/provisioners/docker/cap/debian/docker_install.rb&#34;&gt;ソースコード&lt;/a&gt;を眺めた感じ、常に最新版がインストールされているみたい）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU が複数ある場合は再現率がかなり低くなる&lt;/strong&gt;ようなので、仮想 CPU 数を &lt;code&gt;2&lt;/code&gt; にすることで、とりあえずの対策とした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.vm.provider &amp;quot;virtualbox&amp;quot; do |vm|
  vm.cpus = 2
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ctags に Elixir を追加する</title>
      <link>http://www.metareal.org/post/2015/09/elixir-ctags/</link>
      <pubDate>Fri, 25 Sep 2015 11:09:31 +0900</pubDate>
      
      <guid>http://www.metareal.org/post/2015/09/elixir-ctags/</guid>
      <description>&lt;p&gt;最近、Atom エディタを使っているが、シンボルの定義場所に移動するための &lt;code&gt;Go to Declaration&lt;/code&gt;
コマンドを動作させるためには ctags でインデックスしておく必要がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/atom/symbols-view&#34;&gt;atom/symbols-view&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ただ、2015年9月の現時点では &lt;a href=&#34;http://ctags.sourceforge.net/languages.html&#34;&gt;Elixir がサポートされていない&lt;/a&gt;ようなので、自分で追加してやる必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% ctags --version
Exuberant Ctags 5.8, Copyright (C) 1996-2009 Darren Hiebert
  Compiled: Mar 16 2015, 23:48:18
  ...
  Optional compiled features: +wildcards, +regex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ctags はコマンドラインオプションで新しい言語を定義できる。毎回指定するのが面倒な場合は、
&lt;code&gt;$HOME/.ctags&lt;/code&gt; からオプションを読み込んでくれるようだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ctags.sourceforge.net/EXTENDING.html&#34;&gt;Exuberant Ctags: Adding support for a new language&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とりあえず、&lt;code&gt;defmodule&lt;/code&gt; によるモジュール定義を読み込めるようにしてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--langdef=Elixir
--langmap=Elixir:.ex.exs
--regex-elixir=/^[ \t]*defmodule[ \t]+([a-zA-Z0-9_.]+)/\1/m,modules/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ctags&lt;/code&gt; を実行して、生成された tags ファイルを確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;% ctags lib/elixir/lib/task.ex
% cat tags
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;&amp;quot; to lines/
...
Task	lib/elixir/lib/task.ex	/^defmodule Task do$/;&amp;quot;	m
TaskFinder	lib/elixir/lib/task.ex	/^      defmodule TaskFinder do$/;&amp;quot;	m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想定通り、モジュール定義がインデックスできているようだ。あとは 必要なだけ &lt;code&gt;--regex-elixir&lt;/code&gt; オプションを追加していけばいい。
参考までに、関数定義を追加したものを&lt;a href=&#34;https://gist.github.com/ishikawa/3fad0d2058d68419d3ad&#34;&gt;ここ&lt;/a&gt;に置いておく。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Aliasing Traits</title>
      <link>http://www.metareal.org/post/2015/07/rust-trait-alias/</link>
      <pubDate>Sun, 26 Jul 2015 10:10:37 +0900</pubDate>
      
      <guid>http://www.metareal.org/post/2015/07/rust-trait-alias/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.rust-lang.org&#34;&gt;Rust&lt;/a&gt; の &lt;a href=&#34;https://doc.rust-lang.org/book/traits.html&#34;&gt;Traits&lt;/a&gt; による制約は &lt;a href=&#34;https://doc.rust-lang.org/stable/book/associated-types.html&#34;&gt;Associated Types&lt;/a&gt; や複数の Traits を &lt;code&gt;+&lt;/code&gt; で指定したりすると、どんどん長くなってしまう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct A&amp;lt;T: Iterator&amp;lt;Item=char&amp;gt;&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常の型には &lt;a href=&#34;https://doc.rust-lang.org/book/type-aliases.html&#34;&gt;&lt;code&gt;type&lt;/code&gt; キーワード&lt;/a&gt;による別名づけの手段が用意されているが、これは Traits には使えない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;type CharIterator = Iterator&amp;lt;Item=char&amp;gt;;

// ERROR: note: `type` aliases cannot be used for traits
struct A&amp;lt;T: CharIterator&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;過去に提案はあったが却下されたようだ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/rust-lang/rust/issues/8634&#34;&gt;Allow &lt;code&gt;type&lt;/code&gt; to create an alias for several trait bounds · Issue #8634 · rust-lang/rust&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;別名を与えたい Trait を継承した空の Trait をつくればいい&lt;/li&gt;
&lt;li&gt;言語に新しい機能をつけくわえるほどの価値はなさそう&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;たしかに、空の Trait をつくることで似たような効果を得ることはできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait CharIterator: Iterator&amp;lt;Item=char&amp;gt; {}

struct A&amp;lt;T: CharIterator&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、既存の &lt;code&gt;Iterator&amp;lt;Item=char&amp;gt;&lt;/code&gt; を実装している型 (&lt;a href=&#34;https://doc.rust-lang.org/std/str/struct.Chars.html&#34;&gt;&lt;code&gt;std::str::Chars&lt;/code&gt;&lt;/a&gt; など) は、今回追加した &lt;code&gt;CharIterator&lt;/code&gt; を実装しているわけではないので、このままだと &lt;code&gt;T&lt;/code&gt; の実体として使うことができない。&lt;/p&gt;

&lt;p&gt;「&lt;code&gt;Iterator&amp;lt;Item=char&amp;gt;&lt;/code&gt; を実装した型が &lt;code&gt;CharIterator&lt;/code&gt; も実装している」という &lt;code&gt;impl&lt;/code&gt; を書いておこう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait CharIterator: Iterator&amp;lt;Item=char&amp;gt; {}
impl&amp;lt;T: Iterator&amp;lt;Item=char&amp;gt;&amp;gt; CharIterator for T {}

struct A&amp;lt;T: CharIterator&amp;gt; {
    it: T,
}

...

let a = A { it: &amp;quot;test&amp;quot;.chars() };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考にした記事&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rust-lang/rust/issues/8634&#34;&gt;Allow &lt;code&gt;type&lt;/code&gt; to create an alias for several trait bounds · Issue #8634 · rust-lang/rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/26070559/alias-on-compound-type-in-rust&#34;&gt;Alias on compound type in Rust - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/30424100/aliasing-trait-with-associated-types&#34;&gt;rust - Aliasing trait with associated types - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ブログを Hugo に移行した</title>
      <link>http://www.metareal.org/post/migrate-to-hugo/</link>
      <pubDate>Sun, 21 Jun 2015 14:43:15 +0900</pubDate>
      
      <guid>http://www.metareal.org/post/migrate-to-hugo/</guid>
      <description>

&lt;p&gt;すでに4年半近くの時が経過したが、ひさしぶりの投稿だ。Google AppEngine (Python + Django) で動かしていた自作ブログエンジンを &lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; に移行している。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org&#34;&gt;Go&lt;/a&gt; で実装されているおかげでもあるのだろうが、サイトの生成スピードが速い。組み込みサーバには、ファイルの変更を検知してサイトを更新する機能が備わっているので、ストレスなく記事を書くことができる。ブラウザのリロードも不要。&lt;/p&gt;

&lt;p&gt;URL を記事ごとに指定可能なのは助かった。デフォルトだと &lt;code&gt;/post/title/&lt;/code&gt; のような URL になるのだが、古い記事は &lt;code&gt;/YYYY/MM/DD/title/&lt;/code&gt; という形式で URL を決めていたので、そのままだと URL が変わってしまう。記事中の YAML (&lt;a href=&#34;http://gohugo.io/content/front-matter/&#34;&gt;Front Matter&lt;/a&gt;) で URL を上書きしてやることで、URL を変えずにすんだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
title: &amp;quot;Ruby-FFI 1.0.0 からは Ruby 1.9.2 以降が必要になった。&amp;quot;
url: &amp;quot;/2010/12/16/ffi-requires-ruby-version-1-9-2/&amp;quot;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とはいえ、今後もこの指定をしていくのはしんどいので、この記事から URL の形式を &lt;code&gt;/post/title/&lt;/code&gt; に変えるつもり。&lt;/p&gt;

&lt;h3 id=&#34;移行スクリプト&#34;&gt;移行スクリプト&lt;/h3&gt;

&lt;p&gt;移行にあたっては古い記事を Markdown + Front Matter に変換する必要があり、変換スクリプトを Ruby で書いた。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;指定された記事の URL から HTML を取得&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.nokogiri.org/&#34;&gt;Nokogiri&lt;/a&gt; で HTML をパースしてタイトルや日付といったメタデータを抽出&lt;/li&gt;
&lt;li&gt;本文を Markdown に変換&lt;/li&gt;
&lt;li&gt;Hugo コマンドを起動してファイル作成&lt;/li&gt;
&lt;li&gt;Markdown を書き込んで、次に実行するコマンドを出力&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;移行しながら発展させていき、最終的には上のようなスクリプトに落ち着いた。
最初のうちは 3 までをスクリプトでやって残りは（変換結果が正しいことを確認しつつ）手作業だったのだが、
しばらくしてから 4, 5 を実装して一気に終わらせた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>映画「LOOPER」</title>
      <link>http://www.metareal.org/2013/01/18/looper/</link>
      <pubDate>Fri, 18 Jan 2013 00:00:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2013/01/18/looper/</guid>
      <description>&lt;p&gt;話題の映画「&lt;a href=&#34;http://looper.gaga.ne.jp/&#34;&gt;LOOPER&lt;/a&gt;」を観てきた。&lt;/p&gt;

&lt;p&gt;タイムトラベルものでありながら、主人公自身はタイムトラベルしないのが珍しい。先行作品へのオマージュに満ちあふれた本作だが、以下の二点において
映画「&lt;a href=&#34;http://www.amazon.co.jp/dp/B000BX4ANY&#34;&gt;ターミネーター&lt;/a&gt;」がもっとも近い気がした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;未来と現代が拮抗する物語である&lt;/li&gt;
&lt;li&gt;タイムトラベルが両者の衝突を生み出すための道具としてしか使われていない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一見、自己犠牲に見えるラストも、個人的には「ターミネーター」の別解として考えるのが腑に落ちた。&lt;/p&gt;

&lt;p&gt;前半は最高にスリリングで、申し分のない面白さ。惜しむらくは、後半の展開が少々雑というか、色んな要素を詰め込みすぎた感はある。 未来の悪党どもに利用され蹂躙されている現代社会や、登場人物たちの悲劇の連鎖、といったループ構造が物語の本質だと思うが、飾りが多くてそこが見えづらい。とても楽しませてもらったのだけど、観賞後、冷静になってみるといまいちスッキリしないモヤモヤ感が残った（だからこそ観終わったあとに語りたくなって、話題になるのかもしれない）。&lt;/p&gt;

&lt;p&gt;とはいえ、斬新なアイデアとサービス精神たっぷりのエンターテイメント作品であることは間違いない。新宿バルト9の前列席は音量が大きすぎて、銃撃戦は片耳を塞がないとツラかったが&amp;hellip;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Code Reading: Dump and Print Function in llvm::Module Class</title>
      <link>http://www.metareal.org/2013/01/14/code-reading-dump-and-print-function-in-llvm-module-class/</link>
      <pubDate>Mon, 14 Jan 2013 00:00:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2013/01/14/code-reading-dump-and-print-function-in-llvm-module-class/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://llvm.org/releases/download.html#3.1&#34;&gt;LLVM 3.1&lt;/a&gt; のソースコードから、&lt;a href=&#34;http://llvm.org/doxygen/classllvm_1_1Module.html&#34;&gt;llvm::Module&lt;/a&gt; の IR 出力用関数のソースコードを読んだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// Print the module to an output stream with an optional
/// AssemblyAnnotationWriter.
void print(raw_ostream &amp;amp;OS, AssemblyAnnotationWriter *AAW) const;

/// Dump the module to stderr (for debugging).
void dump() const;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実装は &lt;code&gt;lib/VMCore/Module.cpp&lt;/code&gt; ではなく、他の IR 出力用関数とともに &lt;code&gt;lib/VMCore/AsmWriter.cpp&lt;/code&gt; にまとめられている。まずは &lt;code&gt;llvm::Module::print&lt;/code&gt; を見てみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void Module::print(raw_ostream &amp;amp;ROS, AssemblyAnnotationWriter *AAW) const {
  SlotTracker SlotTable(this);
  formatted_raw_ostream OS(ROS);
  AssemblyWriter W(OS, SlotTable, this, AAW);
  W.printModule(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;llvm-module-print&#34;&gt;llvm::Module::print&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AssemblyWriter&lt;/code&gt; は &lt;code&gt;lib/VMCore/AsmWriter.cpp&lt;/code&gt; の無名ネームスペースに定義されているクラスであり、llvm 内のさまざまな型をストリームに出力する関数を提供している。&lt;code&gt;AssemblyWriter::printModule&lt;/code&gt; のコードをざっと眺めてみれば、やっていることの想像はつくだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void AssemblyWriter::printModule(const Module *M) {
  if (!M-&amp;gt;getModuleIdentifier().empty() &amp;amp;&amp;amp;
      // Don&#39;t print the ID if it will start a new line (which would
      // require a comment char before it).
      M-&amp;gt;getModuleIdentifier().find(&#39;\n&#39;) == std::string::npos)
    Out &amp;lt;&amp;lt; &amp;quot;; ModuleID = &#39;&amp;quot; &amp;lt;&amp;lt; M-&amp;gt;getModuleIdentifier() &amp;lt;&amp;lt; &amp;quot;&#39;\n&amp;quot;;
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;llvm-module-dump&#34;&gt;llvm::Module::dump&lt;/h2&gt;

&lt;p&gt;同じく &lt;code&gt;lib/VMCore/AsmWriter.cpp&lt;/code&gt; の最後の方に定義されている &lt;code&gt;llvm::Module::dump&lt;/code&gt; はどうなっているだろうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Module::dump() - Allow printing of Modules from the debugger.
void Module::dump() const { print(dbgs(), 0); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;llvm::Module::print&lt;/code&gt; を呼んでいるだけだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一引数の raw_ostream には dbgs()&lt;/li&gt;
&lt;li&gt;第二引数の AssemblyAnnotationWriter* には 0 (null pointer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;では、第一引数に渡している dbgs 関数の戻り値はなんだろうか？&lt;/p&gt;

&lt;h2 id=&#34;llvm-dbgs&#34;&gt;llvm::dbgs&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;llvm::dbgs&lt;/code&gt; の宣言は &lt;code&gt;include/llvm/Support/Debug.h&lt;/code&gt; にある。デバッグ用の出力ストリーム (raw_ostream) を返す関数だ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// dbgs() - This returns a reference to a raw_ostream for debugging
/// messages.  If debugging is disabled it returns errs().  Use it
/// like: dbgs() &amp;lt;&amp;lt; &amp;quot;foo&amp;quot; &amp;lt;&amp;lt; &amp;quot;bar&amp;quot;;
raw_ostream &amp;amp;dbgs();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実装は &lt;code&gt;lib/Support/Debug.cpp&lt;/code&gt; で定義されており、&lt;code&gt;NDEBUG&lt;/code&gt; が宣言されているか (非デバッグ・モード) 宣言されていないか (デバッグ・モード) で実装が切り替わるようになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// All Debug.h functionality is a no-op in NDEBUG mode.
#ifndef NDEBUG
/// dbgs - Return a circular-buffered debug stream.
raw_ostream &amp;amp;llvm::dbgs() {
...
}
...
#else
// Avoid &amp;quot;has no symbols&amp;quot; warning.
namespace llvm {
  /// dbgs - Return errs().
  raw_ostream &amp;amp;dbgs() {
    return errs();
  }
}

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非デバッグ・モードのとき &lt;code&gt;dbgs()&lt;/code&gt; は単に標準エラー出力への raw_ostream を返す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifndef STDERR_FILENO
# define STDERR_FILENO 2
#endif
...
/// errs() - This returns a reference to a raw_ostream for standard error.
/// Use it like: errs() &amp;lt;&amp;lt; &amp;quot;foo&amp;quot; &amp;lt;&amp;lt; &amp;quot;bar&amp;quot;;
raw_ostream &amp;amp;llvm::errs() {
  // Set standard error to be unbuffered by default.
  static raw_fd_ostream S(STDERR_FILENO, false, true);
  return S;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デバッグ・モードの場合の実装も見てみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// dbgs - Return a circular-buffered debug stream.
raw_ostream &amp;amp;llvm::dbgs() {
  // Do one-time initialization in a thread-safe way.
  static struct dbgstream {
    circular_raw_ostream strm;

    dbgstream() :
        strm(errs(), &amp;quot;*** Debug Log Output ***\n&amp;quot;,
             (!EnableDebugBuffering || !DebugFlag) ? 0 : DebugBufferSize) {
      if (EnableDebugBuffering &amp;amp;&amp;amp; DebugFlag &amp;amp;&amp;amp; DebugBufferSize != 0)
        // TODO: Add a handler for SIGUSER1-type signals so the user can
        // force a debug dump.
        sys::AddSignalHandler(&amp;amp;debug_user_sig_handler, 0);
      // Otherwise we&#39;ve already set the debug stream buffer size to
      // zero, disabling buffering so it will output directly to errs().
    }
  } thestrm;

  return thestrm.strm;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デバッグ・モードの場合は、標準エラー出力をラップした circular_raw_ostream を返している。static な構造体のコンストラクタで初期化することで、 シグナル・ハンドラなども設定しているのが興味深い。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby-FFI 1.0.0 からは Ruby 1.9.2 以降が必要になった</title>
      <link>http://www.metareal.org/2010/12/16/ffi-requires-ruby-version-1-9-2/</link>
      <pubDate>Thu, 16 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>http://www.metareal.org/2010/12/16/ffi-requires-ruby-version-1-9-2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/ffi/ffi&#34;&gt;Ruby-FFI 1.0.0&lt;/a&gt; からは &lt;a href=&#34;http://groups.google.com/group/ruby-ffi/browse_thread/thread/c40766b574a15962&#34;&gt;Ruby 1.9.2 以降が必要になった&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;% sudo gem1.8 install ffi
Password:
ERROR:  Error installing ffi:
        ffi requires Ruby version &amp;gt;= 1.9.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのため、Ruby 1.8 向けの gem をインストールするときはバージョン 0.6.3 を指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;% sudo gem1.8 install ffi --version &amp;quot;= 0.6.3&amp;quot;
Password:
Building native extensions.  This could take a while...
Successfully installed ffi-0.6.3
1 gem installed
Installing ri documentation for ffi-0.6.3...
Installing RDoc documentation for ffi-0.6.3...
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ruby FFI のメモリ管理についてメモ</title>
      <link>http://www.metareal.org/2010/12/11/1292077318/</link>
      <pubDate>Sat, 11 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>http://www.metareal.org/2010/12/11/1292077318/</guid>
      <description>&lt;p&gt;Ruby FFI のメモリ管理についてメモ。FFI::MemoryPointer で確保したメモリを自分で破棄する場合は、autorelease を false にする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;error   = FFI::MemoryPointer.new(:pointer)
...
C.LLVMDisposeMessage(error)
error.autorelease=false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そうしないと、FFI::MemoryPointer は GC 時に確保したメモリを破棄しようとする (&lt;a href=&#34;https://github.com/ffi/ffi/blob/1.0.1/ext/ffi_c/MemoryPointer.c#L138&#34;&gt;MemoryPointer.c#L138&lt;/a&gt;) ので、たとえば Mac OS X では以下のようなエラーが出る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruby(891,0x7fff70874ca0) malloc: *** error for object 0x102e8fb10: pointer being freed was not allocated
*** set a breakpoint in malloc_error_break to debug
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラー処理とかでは割と忘れがちかもしれない。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LLVM 2.8 の C API 差分をチェックしてはじめて気づいたけど、2.8...</title>
      <link>http://www.metareal.org/2010/12/05/1291551820/</link>
      <pubDate>Sun, 05 Dec 2010 09:23:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2010/12/05/1291551820/</guid>
      <description>&lt;p&gt;LLVM 2.8 の &lt;a href=&#34;https://gist.github.com/728757&#34;&gt;C API 差分&lt;/a&gt;をチェックしてはじめて気づいたけど、2.8 からは Union Type がなくなったみたい。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The LLVM IR &amp;lsquo;Union&amp;rsquo; feature was removed. While this is a desirable feature for LLVM IR to support, the existing implementation was half baked and barely useful. We&amp;rsquo;d really like anyone interested to resurrect the work and finish it for a future release.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://llvm.org/docs/ReleaseNotes.html#changes&#34;&gt;LLVM 2.8 Release Notes | Major Changes and Removed Features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lists.cs.uiuc.edu/pipermail/llvmdev/2010-September/034448.html&#34;&gt;[LLVMdev] Union type, is it really used or necessary?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;現在の実装は不完全で、また、不足分を実装しメンテする開発者がおらず優先順位も低い、ということが理由のようだ。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s just a matter of priorities, unfortunately&amp;hellip; :(&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;http://lists.cs.uiuc.edu/pipermail/llvmdev/2010-September/034451.html&#34;&gt;http://lists.cs.uiuc.edu/pipermail/llvmdev/2010-September/034451.html&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lots of people agree it would be a useful feature, we are lacking a useful implementation :-)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;http://lists.cs.uiuc.edu/pipermail/llvmdev/2010-September/034484.html&#34;&gt;http://lists.cs.uiuc.edu/pipermail/llvmdev/2010-September/034484.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google Bookmark が快適すぎる</title>
      <link>http://www.metareal.org/2010/02/23/google-bookmark-makes-me-feel-so-good/</link>
      <pubDate>Tue, 23 Feb 2010 23:26:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2010/02/23/google-bookmark-makes-me-feel-so-good/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.google.com/bookmarks/&#34;&gt;Google Bookmark&lt;/a&gt; を使いはじめた。シンプルながら快適な使い心地で気に入っている。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;とにかく、ブックマーク編集画面が開くまでが速い&lt;/li&gt;
&lt;li&gt;ブックマーク先のページも含めて全文検索が可能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ソーシャル要素は考えず、純粋に「ブックマーク」という行為を突き詰めていくと、上記二点が非常に重要であることが分かると思う。&lt;/p&gt;

&lt;p&gt;ちなみに、ブックマークレットには&lt;a href=&#34;http://winmac.blog33.fc2.com/blog-entry-63.html&#34;&gt;Googleブックマークに追加するブックマークレット（メモ欄対応版）&lt;/a&gt;で配布されているものを別窓で開くようにして使わせてもらっている。感謝。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javascript:var%20u=encodeURIComponent(location.href);var%20ti=encodeURIComponent(document.title);var%20te=encodeURIComponent((window.getSelection&amp;amp;&amp;amp;window.getSelection())||(document.getSelection&amp;amp;&amp;amp;document.getSelection())||(document.selection&amp;amp;&amp;amp;document.selection.createRange&amp;amp;&amp;amp;document.selection.createRange().text));window.open((te!=&#39;&#39;)?&#39;http://www.google.com/bookmarks/mark?op=add&amp;amp;bkmk=&#39;+u+&#39;&amp;amp;title=&#39;+ti+&#39;&amp;amp;annotation=&#39;+te:&#39;http://www.google.com/bookmarks/mark?op=add&amp;amp;bkmk=&#39;+u+&#39;&amp;amp;title=&#39;+ti);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Python のクロージャとレキシカル変数を使ったシングルトンっぽいもの</title>
      <link>http://www.metareal.org/2010/01/31/python-shared-instance-closure/</link>
      <pubDate>Sun, 31 Jan 2010 18:26:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2010/01/31/python-shared-instance-closure/</guid>
      <description>&lt;p&gt;実際にはシングルトンではなくて、共有インスタンスを返すメソッドを実装する、ってだけなんだけど。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class A(object):

    @staticmethod
    def shared():
        instance = A()
        A.shared = staticmethod(lambda: instance)
        return instance
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;共有インスタンスとなるオブジェクトを生成し、レキシカル変数にバインドする&lt;/li&gt;
&lt;li&gt;このオブジェクトを返す無名関数で、元の関数 shared を置き換える&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;何が嬉しいかというと、共有インスタンスを参照するための変数（今回の場合は &lt;code&gt;instance&lt;/code&gt;）を関数外から不可視にできること。変数のスコープが必要以上に広いと不安になります。実行時に遅延インスタンス化されるのが嫌なら、クラス定義の直後に一度呼び出すなりすればいいと思う。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gist.github.com/290628&#34;&gt;gist:290628&lt;/a&gt; に doctest とか追加したものを置いてあります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google AppEngine で Django 1.1 を使う</title>
      <link>http://www.metareal.org/2009/12/02/running-django-1-1-on-google-appengine/</link>
      <pubDate>Thu, 03 Dec 2009 12:42:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2009/12/02/running-django-1-1-on-google-appengine/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://code.google.com/appengine/&#34;&gt;Google AppEngine&lt;/a&gt; の SDK および実行環境には、Web アプリケーション・フレームワークの &lt;a href=&#34;http://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt; がプリインストールされている。&lt;/p&gt;

&lt;p&gt;しかし、デフォルトで有効になっているのは 0.96 という相当古いバージョンだ（もっとも、Google AppEngine リリース時点では、これが最新のバージョンであった）。すでにサポートも終了しており、バグや脆弱性の修正もされないため、できれば最新の 1.0/1.1系列を使いたい、という人が大半だろう。&lt;/p&gt;

&lt;p&gt;しかし、これまで、バージョン 1.0 以降の Django を Google AppEngine で使うのは骨の折れる作業だった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使いたいバージョンの Django を丸ごとアップロードしなくてはいけなかった&lt;/li&gt;
&lt;li&gt;Django はファイル数が多いため、アップロード可能なファイル数制限を超えやすい&lt;/li&gt;
&lt;li&gt;デフォルトで有効になる古いバージョンの Django を無効化するために、&lt;a href=&#34;http://code.google.com/intl/en/appengine/articles/django.html&#34;&gt;呪文めいたコードが必要&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;だが、いまや状況は変わった。SDK &lt;a href=&#34;http://code.google.com/p/googleappengine/wiki/SdkReleaseNotes#Version_1.2.3_-_June_18,_2009&#34;&gt;1.2.3 からは Django 1.0&lt;/a&gt; が、SDK &lt;a href=&#34;http://code.google.com/p/googleappengine/wiki/SdkReleaseNotes#Version_1.2.5_-_September_3,_2009&#34;&gt;1.2.5 からは Django 1.1&lt;/a&gt; がサポートされ、Google AppEngine でも、簡単に Django 1.x を動かせるようになった。&lt;/p&gt;

&lt;h3 id=&#34;google-appengine-dist-use-library&#34;&gt;google.appengine.dist.use_library&lt;/h3&gt;

&lt;p&gt;SDK 1.2.&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;.2.5 からは &lt;a href=&#34;http://code.google.com/p/googleappengine/source/browse/#svn/trunk/python/google/appengine/dist&#34;&gt;google.appengine.dist&lt;/a&gt; モジュールの &lt;code&gt;use_library&lt;/code&gt; 関数を使うことで Django 1.0/1.1 を選択できるようになった。&lt;/p&gt;

&lt;p&gt;使い方は簡単で、&lt;code&gt;main.py&lt;/code&gt; に以下のような記述を追加するだけだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import os
os.environ[&#39;DJANGO_SETTINGS_MODULE&#39;] = &#39;settings&#39;

from google.appengine.dist import use_library
use_library(&#39;django&#39;, &#39;1.1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これまで開発者が各自行っていた &lt;code&gt;sys.path&lt;/code&gt; の調整は &lt;code&gt;use_library&lt;/code&gt; 関数がやってくれる。&lt;/p&gt;

&lt;p&gt;更に嬉しいことに、Django のコードをアップロードする必要もなくなった。Google AppEngine のサーバには Django 1.0/1.1 がインストールされている。ただし、SDK には Django 0.96 しか添付されていないので、1.0/1.1 を使う場合は、あらかじめローカルのマシンに Django 1.0/1.1 をインストールしておこう。&lt;/p&gt;

&lt;h3 id=&#34;django-のバージョンと-dos-攻撃可能な脆弱性について&#34;&gt;Django のバージョンと DoS 攻撃可能な脆弱性について&lt;/h3&gt;

&lt;p&gt;なお、実際に有効になる Django の詳細なバージョンは、本記事執筆時点の 2009 年 11 月で以下のようになっている（&lt;code&gt;django.VERSION&lt;/code&gt; で調べた）。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;use_library&lt;/th&gt;
&lt;th&gt;Django version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;(None)&lt;/td&gt;
&lt;td&gt;0.96.4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;use_library(1.0)&lt;/td&gt;
&lt;td&gt;1.0.2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;use_library(1.1)&lt;/td&gt;
&lt;td&gt;1.1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;del&gt;残念ながら、1.0/1.1 は &lt;a href=&#34;http://www.djangoproject.com/weblog/2009/oct/09/security/&#34;&gt;DoS 攻撃可能な脆弱性が修正されたバージョン&lt;/a&gt; ではないようだ（修正バージョンは 1.0.&lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;.1.1）。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;この脆弱性は &lt;code&gt;EmailField&lt;/code&gt; か &lt;code&gt;URLField&lt;/code&gt; に関連したものなので、それらを使っているプログラムでは Google AppEngine にインストールされた Django のアップデートを待つか、これまでどおりの方法で、修正済みのバージョンをアップロードした方が安全だろう。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Google AppEngine プロジェクトに&lt;a href=&#34;http://code.google.com/p/googleappengine/issues/detail?id=2447&#34;&gt;報告&lt;/a&gt;したところ、GAE で有効になるバージョンは修正済みのものである、とのこと。失礼しました。&lt;/p&gt;

&lt;h3 id=&#34;main-py-のサンプル&#34;&gt;main.py のサンプル&lt;/h3&gt;

&lt;p&gt;実際に &lt;code&gt;use_library&lt;/code&gt; を使ったサンプルを &lt;a href=&#34;http://gist.github.com/245523&#34;&gt;gist:245523&lt;/a&gt; で公開している。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go</title>
      <link>http://www.metareal.org/2009/11/11/go-vim/</link>
      <pubDate>Wed, 11 Nov 2009 10:29:00 +0900</pubDate>
      
      <guid>http://www.metareal.org/2009/11/11/go-vim/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://iolanguage.com/&#34;&gt;Io&lt;/a&gt; と並んで、自らの検索能力が試される名前の &lt;a href=&#34;http://golang.org/&#34;&gt;Go&lt;/a&gt; ですが、実用性と簡潔さを兼ねそなえた言語設計は好感がもてます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% cd $GOROOT
% ls misc/vim/
go.vim
% cp misc/vim/go.vim ~/.vim/syntax/
% cat &amp;amp;gt; ~/.vim/ftdetect/go.vim
au BufRead,BufNewFile *.go set filetype=go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今日はここまで。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>