<!doctype html>
<html class="no-js" lang="ja">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <base href="http://ishikawa.github.io">
  <title>Code Reading: Dump and Print Function in llvm::Module Class</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="canonical" href="http://ishikawa.github.io/2013/01/14/code-reading-dump-and-print-function-in-llvm-module-class/">
  
  <link href="" rel="alternate" type="application/rss+xml" title="METAREAL" />
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/main.css">

  
  <link rel="stylesheet" href="http://ishikawa.github.io/css/application.min.32b5c9dd76f66e3fb16d1d2d9fb2dc1abf73acbd97c8192d1e573f3bc5ddeeb4.css">
  
  
  <link rel="stylesheet" href="http://ishikawa.github.io/css/application.ja.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">
  <link rel="stylesheet" href="css/highlight/solarized_light.css">
  <script src="js/vendor/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>




<article>
  <h1>Code Reading: Dump and Print Function in llvm::Module Class</h1>
  <div class="metadata">
    <p class="date">
      2013/01/14 12:00am
    </p>
    <ul class="tags">
      
    </ul>
  </div>
  <div class="content">
    <p><a href="http://llvm.org/releases/download.html#3.1">LLVM 3.1</a> のソースコードから、<a href="http://llvm.org/doxygen/classllvm_1_1Module.html">llvm::Module</a> の IR 出力用関数のソースコードを読んだ。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">/// Print the module to an output stream with an optional
</span><span style="color:#75715e">/// AssemblyAnnotationWriter.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(raw_ostream <span style="color:#f92672">&amp;</span>OS, AssemblyAnnotationWriter <span style="color:#f92672">*</span>AAW) <span style="color:#66d9ef">const</span>;

<span style="color:#75715e">/// Dump the module to stderr (for debugging).
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump</span>() <span style="color:#66d9ef">const</span>;
</code></pre></div><p>実装は <code>lib/VMCore/Module.cpp</code> ではなく、他の IR 出力用関数とともに <code>lib/VMCore/AsmWriter.cpp</code> にまとめられている。まずは <code>llvm::Module::print</code> を見てみよう。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> Module<span style="color:#f92672">::</span>print(raw_ostream <span style="color:#f92672">&amp;</span>ROS, AssemblyAnnotationWriter <span style="color:#f92672">*</span>AAW) <span style="color:#66d9ef">const</span> {
  SlotTracker <span style="color:#a6e22e">SlotTable</span>(<span style="color:#66d9ef">this</span>);
  formatted_raw_ostream <span style="color:#a6e22e">OS</span>(ROS);
  AssemblyWriter <span style="color:#a6e22e">W</span>(OS, SlotTable, <span style="color:#66d9ef">this</span>, AAW);
  W.printModule(<span style="color:#66d9ef">this</span>);
}
</code></pre></div><h2 id="llvmmoduleprint">llvm::Module::print</h2>
<p><code>AssemblyWriter</code> は <code>lib/VMCore/AsmWriter.cpp</code> の無名ネームスペースに定義されているクラスであり、llvm 内のさまざまな型をストリームに出力する関数を提供している。<code>AssemblyWriter::printModule</code> のコードをざっと眺めてみれば、やっていることの想像はつくだろう。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> AssemblyWriter<span style="color:#f92672">::</span>printModule(<span style="color:#66d9ef">const</span> Module <span style="color:#f92672">*</span>M) {
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>M<span style="color:#f92672">-&gt;</span>getModuleIdentifier().empty() <span style="color:#f92672">&amp;&amp;</span>
      <span style="color:#75715e">// Don&#39;t print the ID if it will start a new line (which would
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// require a comment char before it).
</span><span style="color:#75715e"></span>      M<span style="color:#f92672">-&gt;</span>getModuleIdentifier().find(<span style="color:#e6db74">&#39;\n&#39;</span>) <span style="color:#f92672">==</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">::</span>npos)
    Out <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;; ModuleID = &#39;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> M<span style="color:#f92672">-&gt;</span>getModuleIdentifier() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
...
}
</code></pre></div><h2 id="llvmmoduledump">llvm::Module::dump</h2>
<p>同じく <code>lib/VMCore/AsmWriter.cpp</code> の最後の方に定義されている <code>llvm::Module::dump</code> はどうなっているだろうか。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// Module::dump() - Allow printing of Modules from the debugger.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> Module<span style="color:#f92672">::</span>dump() <span style="color:#66d9ef">const</span> { print(dbgs(), <span style="color:#ae81ff">0</span>); }
</code></pre></div><p><code>llvm::Module::print</code> を呼んでいるだけだ。</p>
<ul>
<li>第一引数の raw_ostream には dbgs()</li>
<li>第二引数の AssemblyAnnotationWriter* には 0 (null pointer)</li>
</ul>
<p>では、第一引数に渡している dbgs 関数の戻り値はなんだろうか？</p>
<h2 id="llvmdbgs">llvm::dbgs</h2>
<p><code>llvm::dbgs</code> の宣言は <code>include/llvm/Support/Debug.h</code> にある。デバッグ用の出力ストリーム (raw_ostream) を返す関数だ。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">/// dbgs() - This returns a reference to a raw_ostream for debugging
</span><span style="color:#75715e">/// messages.  If debugging is disabled it returns errs().  Use it
</span><span style="color:#75715e">/// like: dbgs() &lt;&lt; &#34;foo&#34; &lt;&lt; &#34;bar&#34;;
</span><span style="color:#75715e"></span>raw_ostream <span style="color:#f92672">&amp;</span>dbgs();
</code></pre></div><p>実装は <code>lib/Support/Debug.cpp</code> で定義されており、<code>NDEBUG</code> が宣言されているか (非デバッグ・モード) 宣言されていないか (デバッグ・モード) で実装が切り替わるようになっている。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// All Debug.h functionality is a no-op in NDEBUG mode.
</span><span style="color:#75715e"></span><span style="color:#75715e">#ifndef NDEBUG
</span><span style="color:#75715e"></span><span style="color:#75715e">/// dbgs - Return a circular-buffered debug stream.
</span><span style="color:#75715e"></span>raw_ostream <span style="color:#f92672">&amp;</span>llvm<span style="color:#f92672">::</span>dbgs() {
...
}
...
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span><span style="color:#75715e">// Avoid &#34;has no symbols&#34; warning.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">namespace</span> llvm {
  <span style="color:#75715e">/// dbgs - Return errs().
</span><span style="color:#75715e"></span>  raw_ostream <span style="color:#f92672">&amp;</span>dbgs() {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errs</span>();
  }
}

<span style="color:#75715e">#endif
</span></code></pre></div><p>非デバッグ・モードのとき <code>dbgs()</code> は単に標準エラー出力への raw_ostream を返す。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#ifndef STDERR_FILENO
</span><span style="color:#75715e"># define STDERR_FILENO 2
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>...
<span style="color:#75715e">/// errs() - This returns a reference to a raw_ostream for standard error.
</span><span style="color:#75715e">/// Use it like: errs() &lt;&lt; &#34;foo&#34; &lt;&lt; &#34;bar&#34;;
</span><span style="color:#75715e"></span>raw_ostream <span style="color:#f92672">&amp;</span>llvm<span style="color:#f92672">::</span>errs() {
  <span style="color:#75715e">// Set standard error to be unbuffered by default.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> raw_fd_ostream <span style="color:#a6e22e">S</span>(STDERR_FILENO, false, true);
  <span style="color:#66d9ef">return</span> S;
}
</code></pre></div><p>デバッグ・モードの場合の実装も見てみよう。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">/// dbgs - Return a circular-buffered debug stream.
</span><span style="color:#75715e"></span>raw_ostream <span style="color:#f92672">&amp;</span>llvm<span style="color:#f92672">::</span>dbgs() {
  <span style="color:#75715e">// Do one-time initialization in a thread-safe way.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dbgstream</span> {
    circular_raw_ostream strm;

    dbgstream() <span style="color:#f92672">:</span>
        strm(errs(), <span style="color:#e6db74">&#34;*** Debug Log Output ***</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
             (<span style="color:#f92672">!</span>EnableDebugBuffering <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>DebugFlag) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> DebugBufferSize) {
      <span style="color:#66d9ef">if</span> (EnableDebugBuffering <span style="color:#f92672">&amp;&amp;</span> DebugFlag <span style="color:#f92672">&amp;&amp;</span> DebugBufferSize <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
        <span style="color:#75715e">// TODO: Add a handler for SIGUSER1-type signals so the user can
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// force a debug dump.
</span><span style="color:#75715e"></span>        sys<span style="color:#f92672">::</span>AddSignalHandler(<span style="color:#f92672">&amp;</span>debug_user_sig_handler, <span style="color:#ae81ff">0</span>);
      <span style="color:#75715e">// Otherwise we&#39;ve already set the debug stream buffer size to
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// zero, disabling buffering so it will output directly to errs().
</span><span style="color:#75715e"></span>    }
  } thestrm;

  <span style="color:#66d9ef">return</span> thestrm.strm;
}
</code></pre></div><p>デバッグ・モードの場合は、標準エラー出力をラップした circular_raw_ostream を返している。static な構造体のコンストラクタで初期化することで、 シグナル・ハンドラなども設定しているのが興味深い。</p>

  </div>
</article>

<nav class="pagination">
  <ul>
    
    <li class="next"><i class="fa fa-angle-left"></i><a href="http://ishikawa.github.io/2013/01/18/looper/">映画「LOOPER」</a></li>
    
    
    <li class="prev"><a href="http://ishikawa.github.io/2010/12/16/ffi-requires-ruby-version-1-9-2/">Ruby-FFI 1.0.0 からは Ruby 1.9.2 以降が必要になった</a><i class="fa fa-angle-right"></i></li>
    
  </ul>
</nav>

<footer>
  <ul class="about">
    <li class="mail"><a href="mailto:takanori.ishikawa@gmail.com"><span class='symbol'>&#xe224;</span></a></li>
    <li class="twitter"><a href="https://twitter.com/takanori_is"><span class='symbol'>&#xe286;</span></a></li>
    <li class="github"><a href="https://github.com/ishikawa"><span class='symbol'>&#xe237;</span></a></li>
  </ul>
  <h2><a href="/ja">METAREAL</a></h2>
  <p class="copyright">copyright &copy; 2006-Present Takanori Ishikawa</p>
</footer>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  showProcessingMessages: false,
  messageStyle: 'none',
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  var all = MathJax.Hub.getAllJax(), i;
  for(i = 0; i &lt; all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script>
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


</body>
</html>
